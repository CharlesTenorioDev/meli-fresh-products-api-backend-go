
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/meli-fresh-products-api-backend-t1/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/meli-fresh-products-api-backend-t1/internal/application/application_default.go (0.0%)</option>
				
				<option value="file2">github.com/meli-fresh-products-api-backend-t1/internal/buyer.go (0.0%)</option>
				
				<option value="file3">github.com/meli-fresh-products-api-backend-t1/internal/carries.go (0.0%)</option>
				
				<option value="file4">github.com/meli-fresh-products-api-backend-t1/internal/employee.go (0.0%)</option>
				
				<option value="file5">github.com/meli-fresh-products-api-backend-t1/internal/error.go (0.0%)</option>
				
				<option value="file6">github.com/meli-fresh-products-api-backend-t1/internal/handler/buyer.go (78.5%)</option>
				
				<option value="file7">github.com/meli-fresh-products-api-backend-t1/internal/handler/carries.go (78.9%)</option>
				
				<option value="file8">github.com/meli-fresh-products-api-backend-t1/internal/handler/employee.go (26.9%)</option>
				
				<option value="file9">github.com/meli-fresh-products-api-backend-t1/internal/handler/inbound_orders.go (69.6%)</option>
				
				<option value="file10">github.com/meli-fresh-products-api-backend-t1/internal/handler/locality.go (90.6%)</option>
				
				<option value="file11">github.com/meli-fresh-products-api-backend-t1/internal/handler/product.go (0.0%)</option>
				
				<option value="file12">github.com/meli-fresh-products-api-backend-t1/internal/handler/product_batch.go (0.0%)</option>
				
				<option value="file13">github.com/meli-fresh-products-api-backend-t1/internal/handler/product_records.go (0.0%)</option>
				
				<option value="file14">github.com/meli-fresh-products-api-backend-t1/internal/handler/purchase_order.go (89.3%)</option>
				
				<option value="file15">github.com/meli-fresh-products-api-backend-t1/internal/handler/section.go (77.8%)</option>
				
				<option value="file16">github.com/meli-fresh-products-api-backend-t1/internal/handler/seller.go (93.5%)</option>
				
				<option value="file17">github.com/meli-fresh-products-api-backend-t1/internal/handler/warehouse.go (76.7%)</option>
				
				<option value="file18">github.com/meli-fresh-products-api-backend-t1/internal/inbound_orders.go (0.0%)</option>
				
				<option value="file19">github.com/meli-fresh-products-api-backend-t1/internal/loader/product_type.go (0.0%)</option>
				
				<option value="file20">github.com/meli-fresh-products-api-backend-t1/internal/loader/section.go (0.0%)</option>
				
				<option value="file21">github.com/meli-fresh-products-api-backend-t1/internal/locality.go (100.0%)</option>
				
				<option value="file22">github.com/meli-fresh-products-api-backend-t1/internal/product_batch.go (0.0%)</option>
				
				<option value="file23">github.com/meli-fresh-products-api-backend-t1/internal/purchase_order.go (0.0%)</option>
				
				<option value="file24">github.com/meli-fresh-products-api-backend-t1/internal/repository/buyer.go (0.0%)</option>
				
				<option value="file25">github.com/meli-fresh-products-api-backend-t1/internal/repository/buyer_mysql.go (0.0%)</option>
				
				<option value="file26">github.com/meli-fresh-products-api-backend-t1/internal/repository/carries_mysql.go (0.0%)</option>
				
				<option value="file27">github.com/meli-fresh-products-api-backend-t1/internal/repository/employee.go (0.0%)</option>
				
				<option value="file28">github.com/meli-fresh-products-api-backend-t1/internal/repository/employee_mysql.go (0.0%)</option>
				
				<option value="file29">github.com/meli-fresh-products-api-backend-t1/internal/repository/inbound_orders_mysql.go (0.0%)</option>
				
				<option value="file30">github.com/meli-fresh-products-api-backend-t1/internal/repository/locality_mysql.go (64.8%)</option>
				
				<option value="file31">github.com/meli-fresh-products-api-backend-t1/internal/repository/product.go (0.0%)</option>
				
				<option value="file32">github.com/meli-fresh-products-api-backend-t1/internal/repository/product_batch_mysql.go (0.0%)</option>
				
				<option value="file33">github.com/meli-fresh-products-api-backend-t1/internal/repository/product_records.go (0.0%)</option>
				
				<option value="file34">github.com/meli-fresh-products-api-backend-t1/internal/repository/product_type.go (0.0%)</option>
				
				<option value="file35">github.com/meli-fresh-products-api-backend-t1/internal/repository/product_type_mysql.go (0.0%)</option>
				
				<option value="file36">github.com/meli-fresh-products-api-backend-t1/internal/repository/purchase_order_mysql.go (0.0%)</option>
				
				<option value="file37">github.com/meli-fresh-products-api-backend-t1/internal/repository/section.go (0.0%)</option>
				
				<option value="file38">github.com/meli-fresh-products-api-backend-t1/internal/repository/section_mysql.go (0.0%)</option>
				
				<option value="file39">github.com/meli-fresh-products-api-backend-t1/internal/repository/seller_map.go (0.0%)</option>
				
				<option value="file40">github.com/meli-fresh-products-api-backend-t1/internal/repository/seller_mysql.go (66.7%)</option>
				
				<option value="file41">github.com/meli-fresh-products-api-backend-t1/internal/repository/warehouse_map.go (0.0%)</option>
				
				<option value="file42">github.com/meli-fresh-products-api-backend-t1/internal/section.go (0.0%)</option>
				
				<option value="file43">github.com/meli-fresh-products-api-backend-t1/internal/seller.go (100.0%)</option>
				
				<option value="file44">github.com/meli-fresh-products-api-backend-t1/internal/warehouse.go (0.0%)</option>
				
				<option value="file45">github.com/meli-fresh-products-api-backend-t1/swagger/docs/docs.go (0.0%)</option>
				
				<option value="file46">github.com/meli-fresh-products-api-backend-t1/utils/logger/logger.go (60.0%)</option>
				
				<option value="file47">github.com/meli-fresh-products-api-backend-t1/utils/resterr/rest_err.go (66.7%)</option>
				
				<option value="file48">github.com/meli-fresh-products-api-backend-t1/utils/validator/float.go (0.0%)</option>
				
				<option value="file49">github.com/meli-fresh-products-api-backend-t1/utils/validator/int.go (33.3%)</option>
				
				<option value="file50">github.com/meli-fresh-products-api-backend-t1/utils/validator/string.go (28.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// @title Meli Fresh Products API
// @version 1.0
// @description API for managing fresh products and orders
// @contact.name Bootcampers GO - W5
// @host localhost:8080
// @BasePath /

package main

import (
        "fmt"
        "os"

        "github.com/go-sql-driver/mysql"

        "github.com/meli-fresh-products-api-backend-t1/internal/application"
)

func main() <span class="cov0" title="0">{
        dbURI := os.Getenv("MYSQL_SPRINT_URI")
        if dbURI == "" </span><span class="cov0" title="0">{
                dbURI = "localhost:3306"
        }</span>

        <span class="cov0" title="0">mysqlCfg := mysql.Config{
                User:      "root",
                Passwd:    "meli_pass",
                Net:       "tcp",
                Addr:      dbURI,
                DBName:    "melifresh",
                ParseTime: true,
        }
        cfg := &amp;application.ConfigServerChi{
                ServerAddress: ":8080",
                Dsn:           mysqlCfg.FormatDSN(),
        }
        server := application.NewServerChi(cfg)

        fmt.Println("Server running on port 8080...")

        if err := server.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package application

import (
        "database/sql"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/handler"
        "github.com/meli-fresh-products-api-backend-t1/internal/repository"
        "github.com/meli-fresh-products-api-backend-t1/internal/service"
        httpSwagger "github.com/swaggo/http-swagger"

        _ "github.com/meli-fresh-products-api-backend-t1/swagger/docs"
)

// ConfigServerChi is a struct that represents the configuration for ServerChi
type ConfigServerChi struct {
        // ServerAddress is the address where the server will be listening
        ServerAddress string
        Dsn           string
}

// NewServerChi is a function that returns a new instance of ServerChi
func NewServerChi(cfg *ConfigServerChi) *ServerChi <span class="cov0" title="0">{
        // default values
        defaultConfig := &amp;ConfigServerChi{
                ServerAddress: ":8080",
                Dsn:           "",
        }

        if cfg != nil </span><span class="cov0" title="0">{
                if cfg.ServerAddress != "" </span><span class="cov0" title="0">{
                        defaultConfig.ServerAddress = cfg.ServerAddress
                }</span>

                <span class="cov0" title="0">if cfg.Dsn != "" </span><span class="cov0" title="0">{
                        defaultConfig.Dsn = cfg.Dsn
                }</span>
        }

        <span class="cov0" title="0">return &amp;ServerChi{
                serverAddress: defaultConfig.ServerAddress,
                dsn:           defaultConfig.Dsn,
        }</span>
}

// ServerChi is a struct that implements the Application interface
type ServerChi struct {
        // serverAddress is the address where the server will be listening
        serverAddress string
        dsn           string
}

// Run is a method that runs the application
func (a *ServerChi) Run() (err error) <span class="cov0" title="0">{
        db, err := sql.Open("mysql", a.dsn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer db.Close()

        // - database: ping
        err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rt := chi.NewRouter()
        rt.Use(middleware.Logger)
        rt.Get("/swagger/*", httpSwagger.WrapHandler)

        buMysqlRepository := repository.NewBuyerMysqlRepository(db)
        whRepository := repository.NewRepositoryWarehouse(nil, "db/warehouse.json")
        slRepository := repository.NewSellerMysql(db)
        lcRepository := repository.NewLocalityMysql(db)
        pdRepository := repository.NewProductSQL(db)
        prodRecRepository := repository.NewProductRecordsSQL(db)
        emRepository := repository.NewEmployeeMysql(db)
        inRepository := repository.NewInboundOrderMysql(db)
        scRepository := repository.NewSectionMysql(db)
        pbRepository := repository.NewProductBatchMysql(db)
        ptRepository := repository.NewProductTypeMysql(db)
        poMysqlRepository := repository.NewPurchaseOrderMysqlRepository(db)
        buyerService := service.NewBuyerService(buMysqlRepository)

        rt.Route("/api/v1", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Route("/employees", func(r chi.Router) </span><span class="cov0" title="0">{
                        employeeRouter(r, whRepository, db)
                }</span>)
                <span class="cov0" title="0">r.Route("/buyers", func(r chi.Router) </span><span class="cov0" title="0">{
                        buyerRouter(r, buMysqlRepository)
                }</span>)
                <span class="cov0" title="0">r.Route("/sections", func(r chi.Router) </span><span class="cov0" title="0">{
                        sectionsRoutes(r, scRepository, ptRepository, whRepository, pdRepository)
                }</span>)
                <span class="cov0" title="0">r.Route("/product-batches", func(r chi.Router) </span><span class="cov0" title="0">{
                        productBatchRoutes(r, pbRepository, scRepository, pdRepository)
                }</span>)
                <span class="cov0" title="0">r.Route("/warehouses", func(r chi.Router) </span><span class="cov0" title="0">{
                        warehouseRoute(r, whRepository)
                }</span>)
                <span class="cov0" title="0">r.Route("/sellers", func(r chi.Router) </span><span class="cov0" title="0">{
                        sellerRoutes(r, slRepository, lcRepository)
                }</span>)
                <span class="cov0" title="0">r.Route("/localities", func(r chi.Router) </span><span class="cov0" title="0">{
                        localitiesRoutes(r, lcRepository)
                }</span>)

                <span class="cov0" title="0">r.Route("/products", func(r chi.Router) </span><span class="cov0" title="0">{
                        productRoutes(r, pdRepository, slRepository, ptRepository)
                }</span>)
                <span class="cov0" title="0">r.Route("/purchase-orders", func(r chi.Router) </span><span class="cov0" title="0">{
                        purchaseOrderRouter(r, poMysqlRepository, prodRecRepository, buyerService)
                }</span>)
                <span class="cov0" title="0">r.Route("/carries", func(r chi.Router) </span><span class="cov0" title="0">{
                        carriesRoutes(r, db)
                }</span>)

                <span class="cov0" title="0">r.Route("/productRecords", func(r chi.Router) </span><span class="cov0" title="0">{
                        productRecordsRoutes(r, prodRecRepository, pdRepository)
                }</span>)

                <span class="cov0" title="0">r.Route("/inbound-orders", func(r chi.Router) </span><span class="cov0" title="0">{
                        inboundOrdersRoutes(r, inRepository, emRepository, pbRepository, whRepository)
                }</span>)
        })

        <span class="cov0" title="0">err = http.ListenAndServe(a.serverAddress, rt)

        return err</span>
}

func localitiesRoutes(r chi.Router, lcRepository internal.LocalityRepository) <span class="cov0" title="0">{
        sv := service.NewLocalityDefault(lcRepository)
        hd := handler.NewLocalityDefault(sv)

        r.Get("/report-sellers", hd.ReportSellers())
        r.Get("/report-carries", hd.ReportCarries())
        r.Post("/", hd.Save())
}</span>

func sellerRoutes(r chi.Router, slRepository internal.SellerRepository, lcRepository internal.LocalityRepository) <span class="cov0" title="0">{
        sv := service.NewSellerServiceDefault(slRepository, lcRepository)
        hd := handler.NewSellerDefault(sv)

        r.Get("/", hd.GetAll())
        r.Get("/{id}", hd.GetByID())
        r.Post("/", hd.Save())
        r.Patch("/{id}", hd.Update())
        r.Delete("/{id}", hd.Delete())
}</span>

func warehouseRoute(r chi.Router, whRepository internal.WarehouseRepository) <span class="cov0" title="0">{
        warehouseService := service.NewWarehouseDefault(whRepository)
        warehouseHandler := handler.NewWarehouseDefault(warehouseService)

        r.Get("/", warehouseHandler.GetAll())
        r.Get("/{id}", warehouseHandler.GetByID())
        r.Post("/", warehouseHandler.Create())
        r.Patch("/{id}", warehouseHandler.Update())
        r.Delete("/{id}", warehouseHandler.Delete())
}</span>

func sectionsRoutes(r chi.Router, scRepository internal.SectionRepository, ptRepository internal.ProductTypeRepository, whRepository internal.WarehouseRepository, pdRepository internal.ProductRepository) <span class="cov0" title="0">{
        sv := service.NewServiceSection(scRepository, ptRepository, pdRepository, whRepository)
        hd := handler.NewHandlerSection(sv)

        r.Get("/", hd.GetAll)
        r.Get("/{id}", hd.GetByID)
        r.Get("/report-products", hd.ReportProducts)
        r.Post("/", hd.Create)
        r.Patch("/{id}", hd.Update)
        r.Delete("/{id}", hd.Delete)
}</span>

func productBatchRoutes(r chi.Router, pbRepository internal.ProductBatchRepository, scRepository internal.SectionRepository, ptRepository internal.ProductRepository) <span class="cov0" title="0">{
        sv := service.NewServiceProductBatch(pbRepository, scRepository, ptRepository)
        hd := handler.NewHandlerProductBatch(sv)

        r.Get("/{id}", hd.GetByID)
        r.Post("/", hd.Create)
}</span>

func employeeRouter(r chi.Router, whRepository internal.WarehouseRepository, db *sql.DB) <span class="cov0" title="0">{
        rp := repository.NewEmployeeMysql(db)
        sv := service.NewEmployeeServiceDefault(rp, whRepository)
        hd := handler.NewEmployeeDefault(sv)

        r.Get("/", hd.GetAll)
        r.Get("/{id}", hd.GetByID)
        r.Post("/", hd.Create)
        r.Patch("/{id}", hd.Update)
        r.Delete("/{id}", hd.Delete)
        r.Get("/report-inbound-orders", hd.ReportInboundOrders)
}</span>

func buyerRouter(r chi.Router, buRepository internal.BuyerRepository) <span class="cov0" title="0">{
        svc := service.NewBuyerService(buRepository)
        hd := handler.NewBuyerHandlerDefault(svc)

        r.Get("/", hd.GetAll)
        r.Get("/{id}", hd.GetByID)
        r.Post("/", hd.Create)
        r.Patch("/{id}", hd.Update)
        r.Delete("/{id}", hd.Delete)
        r.Get("/report-purchase-orders", hd.ReportPurchaseOrders)
}</span>

func productRoutes(r chi.Router, pdRepository internal.ProductRepository, slRepository internal.SellerRepository, ptRepository internal.ProductTypeRepository) <span class="cov0" title="0">{
        svc := service.NewProductService(pdRepository, slRepository, ptRepository)
        hd := handler.NewProducHandlerDefault(svc)

        r.Get("/", hd.GetAll)
        r.Get("/{id}", hd.GetByID)
        r.Post("/", hd.Create)
        r.Patch("/{id}", hd.Update)
        r.Delete("/{id}", hd.Delete)
        r.Get("/report-records", hd.ReportRecords)
}</span>

func inboundOrdersRoutes(r chi.Router, inRepository internal.InboundOrdersRepository, emRepository internal.EmployeeRepository, pbRepository internal.ProductBatchRepository, whRepository internal.WarehouseRepository) <span class="cov0" title="0">{
        sv := service.NewInboundOrderService(inRepository, emRepository, pbRepository, whRepository)
        hd := handler.NewInboundOrdersHandler(sv)

        r.Post("/", hd.Create)
        r.Get("/", hd.GetAll)
}</span>

func purchaseOrderRouter(r chi.Router, poRepository internal.PurchaseOrderRepository, prodRecRepository internal.ProductRecordsRepository, buyerService internal.BuyerService) <span class="cov0" title="0">{
        sv := service.NewPurchaseOrderService(poRepository, prodRecRepository, buyerService)
        hd := handler.NewPurchaseOrderHandler(sv)

        r.Post("/", hd.Create())
}</span>

func carriesRoutes(r chi.Router, db *sql.DB) <span class="cov0" title="0">{
        rp := repository.NewCarriesMysql(db)
        sv := service.NewCarriesService(rp)
        hd := handler.NewCarriesHandlerDefault(sv)

        r.Get("/", hd.GetAll)
        r.Post("/", hd.Create)
}</span>
func productRecordsRoutes(r chi.Router, prodRecRepository internal.ProductRecordsRepository, prodRepository internal.ProductRepository) <span class="cov0" title="0">{
        svc := service.NewProductRecordsDefault(prodRecRepository, prodRepository)
        hd := handler.NewProductRecordsDefault(svc)
        r.Post("/", hd.Create)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package internal

type Buyer struct {
        ID           int    `json:"id"`
        CardNumberID string `json:"card_number_id"`
        FirstName    string `json:"first_name"`
        LastName     string `json:"last_name"`
}

type BuyerPatch struct {
        CardNumberID *string `json:"card_number_id,omitempty"`
        FirstName    *string `json:"first_name,omitempty"`
        LastName     *string `json:"last_name,omitempty"`
}

type PurchaseOrdersByBuyer struct {
        BuyerID             int    `json:"id"`
        CardNumberID        string `json:"card_number_id"`
        FirstName           string `json:"first_name"`
        LastName            string `json:"last_name"`
        PurchaseOrdersCount int    `json:"purchase_orders_count"`
}

type BuyerRepository interface {
        GetAll() (db map[int]Buyer)
        Add(buyer *Buyer)
        Update(id int, buyer BuyerPatch)
        Delete(id int)
        ReportPurchaseOrders() (purchaseOrders []PurchaseOrdersByBuyer, err error)
        ReportPurchaseOrdersByID(id int) (purchaseOrders []PurchaseOrdersByBuyer, err error)
}

type BuyerService interface {
        GetAll() map[int]Buyer
        FindByID(id int) (b Buyer, err error)
        Save(buyer *Buyer) (err error)
        Update(id int, buyerPatch BuyerPatch) (err error)
        Delete(id int) (err error)
        ReportPurchaseOrders() (purchaseOrders []PurchaseOrdersByBuyer, err error)
        ReportPurchaseOrdersByID(id int) (purchaseOrders []PurchaseOrdersByBuyer, err error)
}

func (b *Buyer) Parse() (ok bool) <span class="cov0" title="0">{
        ok = true
        if b.CardNumberID == "" || b.LastName == "" || b.FirstName == "" </span><span class="cov0" title="0">{
                ok = false
        }</span>

        <span class="cov0" title="0">return</span>
}

func (b BuyerPatch) Patch(buyerToUpdate *Buyer) <span class="cov0" title="0">{
        if b.CardNumberID != nil </span><span class="cov0" title="0">{
                buyerToUpdate.CardNumberID = *b.CardNumberID
        }</span>

        <span class="cov0" title="0">if b.FirstName != nil </span><span class="cov0" title="0">{
                buyerToUpdate.FirstName = *b.FirstName
        }</span>

        <span class="cov0" title="0">if b.LastName != nil </span><span class="cov0" title="0">{
                buyerToUpdate.LastName = *b.LastName
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package internal

type Carries struct {
        ID          int    `json:"id"`
        Cid         string `json:"cid"`
        CompanyName string `json:"company_name"`
        Address     string `json:"address"`
        PhoneNumber string `json:"phone_number"`
        LocalityID  int    `json:"locality_id"`
}

type CarriesService interface {
        FindAll() (carries []Carries, e error)
        Create(carry Carries) (lastID int64, e error)
}

type CarriesRepository interface {
        FindAll() ([]Carries, error)
        Create(carry Carries) (lastID int64, e error)
}

func (c *Carries) Ok() bool <span class="cov0" title="0">{
        if c.Cid == "" || c.CompanyName == "" || c.Address == "" || c.PhoneNumber == "" || c.LocalityID &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package internal

import "errors"

var ErrEmployeeNotFound = errors.New("employee not found")
var ErrEmployeeConflict = errors.New("employee already in use")

type Employee struct {
        ID           int    `json:"id"`
        CardNumberID string `json:"card_number_id"`
        FirstName    string `json:"first_name"`
        LastName     string `json:"last_name"`
        WarehouseID  int    `json:"warehouse_id"`
}

type EmployeePatch struct {
        CardNumberID *string `json:"card_number_id,omitempty"`
        FirstName    *string `json:"first_name,omitempty"`
        LastName     *string `json:"last_name,omitempty"`
}

type InboundOrdersPerEmployee struct {
        ID            int    `json:"id"`
        CardNumberID  string `json:"card_number_id"`
        FirstName     string `json:"first_name"`
        LastName      string `json:"last_name"`
        WarehouseID   int    `json:"warehouse_id"`
        CountInOrders int    `json:"inbound_orders_count"`
}

func (emp *Employee) RequirementsFields() (ok bool) <span class="cov0" title="0">{
        ok = true
        if emp.CardNumberID == "" || emp.FirstName == "" || emp.LastName == "" || emp.WarehouseID == 0 </span><span class="cov0" title="0">{
                ok = false
        }</span>

        <span class="cov0" title="0">return</span>
}

// EmployeePatch function to update employee data in repository
func (emp EmployeePatch) EmployeePatch(empUpdate *Employee) <span class="cov0" title="0">{
        if emp.CardNumberID != nil </span><span class="cov0" title="0">{
                empUpdate.CardNumberID = *emp.CardNumberID
        }</span>

        <span class="cov0" title="0">if emp.FirstName != nil </span><span class="cov0" title="0">{
                empUpdate.FirstName = *emp.FirstName
        }</span>

        <span class="cov0" title="0">if emp.LastName != nil </span><span class="cov0" title="0">{
                empUpdate.LastName = *emp.LastName
        }</span>
}

type EmployeeRepository interface {
        GetAll() (db []Employee, err error)
        GetByID(id int) (emp Employee, err error)
        Save(emp *Employee) (int, error)
        Update(id int, employee Employee) error
        Delete(id int) error
        CountInboundOrdersPerEmployee() (io []InboundOrdersPerEmployee, err error)
        ReportInboundOrdersByID(employeeID int) (io InboundOrdersPerEmployee, err error)
}

type EmployeeService interface {
        GetAll() (db []Employee, err error)
        GetByID(id int) (emp Employee, err error)
        Save(emp *Employee) (err error)
        Update(employees Employee) (err error)
        Delete(id int) (err error)
        CountInboundOrdersPerEmployee() (io []InboundOrdersPerEmployee, err error)
        ReportInboundOrdersByID(employeeID int) (io InboundOrdersPerEmployee, err error)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package internal

type Causes struct {
        Field   string
        Message string
}

type DomainError struct {
        Message string
        Causes  []Causes
}

func (d DomainError) Error() string <span class="cov0" title="0">{
        return d.Message
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/service"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

type BuyerHandlerDefault struct {
        s internal.BuyerService
}

func NewBuyerHandlerDefault(svc internal.BuyerService) *BuyerHandlerDefault <span class="cov8" title="1">{
        return &amp;BuyerHandlerDefault{
                s: svc,
        }
}</span>

// GetAll godoc
// @Summary Get all buyers
// @Description Retrieve all buyers from the database
// @Tags Buyers
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "List of all buyers"
// @Router /api/v1/buyers [get]
func (h *BuyerHandlerDefault) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        all := h.s.GetAll()

        response.JSON(w, http.StatusOK, map[string]any{
                "data": all,
        })
}</span>

// GetByID godoc
// @Summary Get a buyer by Id
// @Description Retrieve a specific buyer from the database using their Id
// @Tags Buyers
// @Accept json
// @Produce json
// @Param id path int true "Buyer ID"
// @Success 200 {object} map[string]interface{} "Buyer data"
// @Failure 400 {object} rest_err.RestErr "Failed to parse Id"
// @Failure 404 {object} rest_err.RestErr "Buyer not found"
// @Router /api/v1/buyers/{id} [get]
func (h *BuyerHandlerDefault) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("failed to parse id"))

                return
        }</span>

        <span class="cov8" title="1">buyer, err := h.s.FindByID(id)
        if err != nil </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                return
        }</span>

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": buyer,
        })</span>
}

// Create godoc
// @Summary Create a new buyer
// @Description Add a new buyer to the database
// @Tags Buyers
// @Accept json
// @Produce json
// @Param buyer body internal.Buyer true "Buyer data"
// @Success 201 {object} map[string]interface{} "Created buyer"
// @Failure 409 {object} rest_err.RestErr "buyer with given card number already registered"
// @Failure 400 {object} rest_err.RestErr "Invalid input"
// @Failure 422 {object} rest_err.RestErr "Failed to create buyer"
// @Router /api/v1/buyers [post]
func (h *BuyerHandlerDefault) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var buyer internal.Buyer

        err := json.NewDecoder(r.Body).Decode(&amp;buyer)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov8" title="1">err = h.s.Save(&amp;buyer)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, service.ErrBuyerAlreadyExists) || errors.Is(err, service.ErrCardNumberAlreadyInUse) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span> else<span class="cov8" title="1"> {
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                }</span>

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusCreated, map[string]any{
                "data": buyer,
        })</span>
}

// Update godoc
// @Summary Update a buyer's information
// @Description Update the details of an existing buyer in the database
// @Tags Buyers
// @Accept json
// @Produce json
// @Param id path int true "Buyer ID"
// @Param buyer body internal.BuyerPatch true "Buyer patch data"
// @Success 200 {object} map[string]interface{} "Updated buyer"
// @Failure 400 {object} rest_err.RestErr "Failed to parse id" or "Failed to parse body"
// @Failure 404 {object} rest_err.RestErr "Buyer not found"
// @Failure 409 {object} rest_err.RestErr "buyer with given card number already registered"
// @Router /api/v1/buyers/{id} [patch]
func (h *BuyerHandlerDefault) Update(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("failed to parse id"))

                return
        }</span>

        <span class="cov8" title="1">var buyer internal.BuyerPatch

        err = json.NewDecoder(r.Body).Decode(&amp;buyer)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("failed to parse body"))

                return
        }</span>

        <span class="cov8" title="1">err = h.s.Update(id, buyer)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, service.ErrBuyerNotFound) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span>

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": buyer,
        })</span>
}

// Delete godoc
// @Summary Delete a buyer by Id
// @Description Remove a specific buyer from the database
// @Tags Buyers
// @Accept json
// @Produce json
// @Param id path int true "Buyer ID"
// @Success 204 {object} nil "No content"
// @Failure 400 {object} rest_err.RestErr "Failed to parse Id"
// @Failure 404 {object} rest_err.RestErr "Buyer not found"
// @Router /api/v1/buyers/{id} [delete]
func (h *BuyerHandlerDefault) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("failed to parse id"))

                return
        }</span>

        <span class="cov8" title="1">err = h.s.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                return
        }</span>

        <span class="cov8" title="1">response.JSON(w, http.StatusNoContent, nil)</span>
}

// ReportPurchaseOrders godoc
// @Summary Get purchase orders by buyer
// @Description Generate a report of purchase orders for a specific buyer or all buyers
// @Tags Buyers
// @Accept json
// @Produce json
// @Param id query int false "Buyer Id"
// @Success 200 {object} map[string]interface{} "Report data"
// @Failure 400 {object} rest_err.RestErr "failed to parse id"
// @Failure 404 {object} rest_err.RestErr "Buyer not found"
// @Failure 500 {object} rest_err.RestErr "Internal server error"
// @Router /api/v1/buyers/report-purchase-orders [get]
func (h *BuyerHandlerDefault) ReportPurchaseOrders(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var purchaseOrdersByBuyer []internal.PurchaseOrdersByBuyer

        var err error

        // Check if there is an id query parameter and call the corresponding service method
        id := r.URL.Query().Get("id")
        if id != "" </span><span class="cov8" title="1">{
                idInt, parseErr := strconv.Atoi(id)
                if parseErr != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("failed to parse id"))

                        return
                }</span>

                <span class="cov8" title="1">purchaseOrdersByBuyer, err = h.s.ReportPurchaseOrdersByID(idInt)</span>
        } else<span class="cov8" title="1"> {
                purchaseOrdersByBuyer, err = h.s.ReportPurchaseOrders()
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, service.ErrBuyerNotFound):<span class="cov8" title="1">
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))</span>
                default:<span class="cov0" title="0">
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(err.Error()))</span>
                }

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": purchaseOrdersByBuyer,
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        "github.com/bootcamp-go/web/response"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

type CarriesHandlerDefault struct {
        sv internal.CarriesService
}

func NewCarriesHandlerDefault(sv internal.CarriesService) *CarriesHandlerDefault <span class="cov8" title="1">{
        return &amp;CarriesHandlerDefault{sv}
}</span>

// GetAll godoc
// @Summary Get all carries
// @Description Retrieve a list of all carries from the database
// @Tags Carries
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "List of all carries"
// @Failure 500 {object} rest_err.RestErr "failed to fetch carries"
// @Router /api/v1/carries [get]
func (h *CarriesHandlerDefault) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        all, err := h.sv.FindAll()
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError("failed to fetch carries"))

                return
        }</span>

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": all,
        })</span>
}

// Create godoc
// @Summary Create a new carry
// @Description Create a new carry in the database
// @Tags Carries
// @Accept json
// @Produce json
// @Param carry body internal.Carries true "Carry data"
// @Success 201 {object} map[string]interface{} "Created carry with Id"
// @Failure 400 {object} rest_err.RestErr "Failed to parse body"
// @Failure 422 {object} rest_err.RestErr "Missing fields"
// @Failure 409 {object} rest_err.RestErr "carry with this cid already exists" or "there's no such locality id"
// @Router /api/v1/carries [post]
func (h *CarriesHandlerDefault) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var carry internal.Carries

        err := json.NewDecoder(r.Body).Decode(&amp;carry)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("failed to parse body"))

                return
        }</span>

        <span class="cov8" title="1">if ok := carry.Ok(); !ok </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError("missing fields"))
                return
        }</span>

        <span class="cov8" title="1">lastID, err := h.sv.Create(carry)
        if err != nil </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))

                return
        }</span>

        <span class="cov8" title="1">response.JSON(w, http.StatusCreated, map[string]any{
                "data": struct {
                        ID int64 `json:"id"`
                }{
                        ID: lastID,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"
        "strings"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/service"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

type EmployeeHandlerDefault struct {
        sv internal.EmployeeService
}

func NewEmployeeDefault(sv internal.EmployeeService) *EmployeeHandlerDefault <span class="cov8" title="1">{
        return &amp;EmployeeHandlerDefault{
                sv: sv,
        }
}</span>

// GetAll godoc
// @Summary Get all employees
// @Description Retrieve a list of all employees from the database
// @Tags Employees
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "List of all employees"
// @Failure 500 {object} rest_err.RestErr "internal server error"
// @Router /api/v1/employees [get]
func (h *EmployeeHandlerDefault) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        dataEmployee, err := h.sv.GetAll()

        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(err.Error()))

                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        response.JSON(w, http.StatusOK, map[string]any{
                "data": dataEmployee,
        })</span>
}

// GetByID godoc
// @Summary Get an employee by Id
// @Description Retrieve a specific employee by Id
// @Tags Employees
// @Accept json
// @Produce json
// @Param id path int true "Employee ID"
// @Success 200 {object} map[string]interface{} "Employee data"
// @Failure 400 {object} map[string]interface{} "Invalid Id format"
// @Failure 404 {object} map[string]interface{} "Employee not found"
// @Router /api/v1/employees/{id} [get]
func (h *EmployeeHandlerDefault) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, map[string]any{
                        "data": "invalid id format", //status 400
                })

                return
        }</span>

        <span class="cov0" title="0">emp, err := h.sv.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusNotFound, map[string]any{
                        "data": "employee not found", //status 404
                })

                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": emp,
        })</span>
}

// Create godoc
// @Summary Create a new employee
// @Description Create a new employee record in the database
// @Tags Employees
// @Accept json
// @Produce json
// @Param employee body internal.Employee true "Employee data"
// @Success 201 {object} map[string]interface{} "Created employee"
// @Failure 400 {object} map[string]interface{} "Invalid body format"
// @Failure 409 {object} map[string]interface{} "Card number id already in use" or "Employee already in use"
// @Failure 422 {object} map[string]interface{} "Invalid entity data"
// @Router /api/v1/employees [post]
func (h *EmployeeHandlerDefault) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var employee internal.Employee

        err := json.NewDecoder(r.Body).Decode(&amp;employee)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, map[string]any{
                        "data": "invalid body format", //status 400
                })

                return
        }</span>

        <span class="cov8" title="1">err = h.sv.Save(&amp;employee) // save employee in service

        // checks if card number Id field is already in use, because it's a unique field
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, service.ErrCardNumberIDInUse) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusConflict, map[string]any{
                                "error": "card number id already in use", // Status 409
                        })
                }</span> else<span class="cov0" title="0"> if errors.Is(err, service.ErrEmployeeInUse) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusConflict, map[string]any{
                                "error": "employee already in use", // Status 409
                        })
                }</span> else<span class="cov0" title="0"> {
                        response.JSON(w, http.StatusUnprocessableEntity, map[string]any{
                                "data": err.Error(), // status 422
                        })
                }</span>

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusCreated, map[string]any{
                "data": employee,
        })</span>
}

// Update godoc
// @Summary Update an existing employee
// @Description Update the details of an existing employee by Id
// @Tags Employees
// @Accept json
// @Produce json
// @Param id path int true "Employee ID"
// @Param employee body internal.Employee true "Employee data"
// @Success 200 {object} map[string]interface{} "Updated employee"
// @Failure 400 {object} map[string]interface{} "Invalid Id format" or "Invalid body format"
// @Failure 404 {object} map[string]interface{} "Employee not found"
// @Failure 409 {object} map[string]interface{} "Card number id already in use" or "Conflict in employee"
// @Router /api/v1/employees/{id} [patch]
func (h *EmployeeHandlerDefault) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil || id &lt;= 0 </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, map[string]any{
                        "data": "invalid id format", //status 400
                })

                return
        }</span>

        <span class="cov0" title="0">var employee internal.Employee

        err = json.NewDecoder(r.Body).Decode(&amp;employee)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, map[string]any{
                        "data": "invalid body format",
                })

                return
        }</span>

        <span class="cov0" title="0">employee.ID = id

        err = h.sv.Update(employee)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrEmployeeNotFound) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusNotFound, map[string]any{
                                "data": err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        response.JSON(w, http.StatusConflict, map[string]any{
                                "data": err.Error(),
                        })
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">updatedEmployee, err := h.sv.GetByID(employee.ID)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusInternalServerError, map[string]any{
                        "data": "error retrieving updated employee",
                })

                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": updatedEmployee,
        })</span>
}

// Delete godoc
// @Summary Delete an employee by Id
// @Description Remove an employee record from the database by Id
// @Tags Employees
// @Accept json
// @Produce json
// @Param id path int true "Employee ID"
// @Success 204 {object} nil "No Content"
// @Failure 400 {object} map[string]interface{} "Invalid Id format"
// @Failure 404 {object} map[string]interface{} "Employee not found"
// @Router /api/v1/employees/{id} [delete]
func (h *EmployeeHandlerDefault) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, map[string]any{
                        "data": "invalid id format",
                })

                return
        }</span>

        <span class="cov0" title="0">err = h.sv.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusNotFound, map[string]any{
                        "data": "employee not found",
                })

                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusNoContent, nil)</span>
}

// ReportInboundOrders godoc
// @Summary Get inbound orders for employees
// @Description Retrieve the count all inbound orders per employee, or for a specific employee if Id is provided
// @Tags Employees
// @Accept json
// @Produce json
// @Param id query int false "Employee ID"
// @Success 200 {object} map[string]interface{} "Count of inbound orders per employee"
// @Failure 400 {object} rest_err.RestErr "Id should be a number"
// @Failure 404 {object} rest_err.RestErr "Employee not found"
// @Failure 500 {object} rest_err.RestErr "Failed to fetch inbound orders"
// @Router /api/v1/employees/report-inbound-orders [get]
func (h *EmployeeHandlerDefault) ReportInboundOrders(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := r.URL.Query().Get("id")
        idStr = strings.TrimSpace(idStr)

        switch </span>{
        case idStr == "":<span class="cov8" title="1">
                inboundOrders, err := h.sv.CountInboundOrdersPerEmployee()
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError("failed to fetch inbound orders"))

                        return
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": inboundOrders,
                })

                return</span>

        default:<span class="cov0" title="0">
                id, err := strconv.Atoi(idStr)

                switch </span>{
                case err != nil:<span class="cov0" title="0">
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("id should be a number"))

                        return</span>
                }

                <span class="cov0" title="0">countInboundOrders, err := h.sv.ReportInboundOrdersByID(id)

                switch </span>{
                case err != nil:<span class="cov0" title="0">
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError("employee not found"))

                        return</span>
                }

                <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                        "data": countInboundOrders,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        "github.com/bootcamp-go/web/response"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

type InboundOrdersHandler struct {
        sv internal.InboundOrderService
}

func NewInboundOrdersHandler(sv internal.InboundOrderService) *InboundOrdersHandler <span class="cov8" title="1">{
        return &amp;InboundOrdersHandler{
                sv: sv,
        }
}</span>

// Create godoc
// @Summary Create a new inbound order
// @Description Create a new inbound order with the provided details
// @Tags InboundOrders
// @Accept json
// @Produce json
// @Param inbound body internal.InboundOrders true "Inbound order data"
// @Success 201 {object} map[string]interface{} "Created inbound order with ID"
// @Failure 400 {object} map[string]interface{} "Invalid body format"
// @Failure 422 {object} map[string]interface{} "Required fields are missing"
// @Failure 409 {object} map[string]interface{} "Order number already exists" or "Employee not exists"
// @Router /api/v1/inbound-orders [post]
func (h *InboundOrdersHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var inbound internal.InboundOrders

        err := json.NewDecoder(r.Body).Decode(&amp;inbound)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, map[string]any{
                        "error": "invalid body format", //status code 400
                })

                return
        }</span>

        <span class="cov8" title="1">if okFields := inbound.ValidateFieldsOk(); !okFields </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusUnprocessableEntity, map[string]any{
                        "error": "required fields are missing", //status code 422
                })

                return
        }</span>

        <span class="cov8" title="1">lastID, err := h.sv.Create(inbound)
        if err != nil </span><span class="cov8" title="1">{
                if err == internal.ErrOrderNumberAlreadyExists </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusConflict, map[string]any{
                                "error": "order number already exists", //status code 409
                        })

                        return
                }</span>

                <span class="cov0" title="0">if err == internal.ErrEmployeeNotFound </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusConflict, map[string]any{
                                "error": "employee not exists", //status code 409
                        })

                        return
                }</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusCreated, map[string]any{
                "data": struct {
                        ID int64 `json:"id"`
                }{
                        ID: lastID, //last id generated
                },
        })</span>
}

// GetAll godoc
// @Summary Get all inbound orders
// @Description Retrieve a list of all inbound orders from the database
// @Tags InboundOrders
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "List of inbound orders"
// @Failure 500 {object} rest_err.RestErr "Failed to fetch inbounds orders"
// @Router /api/v1/inbound-orders [get]
func (h *InboundOrdersHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        allInbounds, err := h.sv.FindAll()
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError("failed to fetch inbounds orders"))

                return
        }</span>

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": allInbounds,
        })</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "go.uber.org/zap"

        "github.com/bootcamp-go/web/response"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/utils/logger"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

// NewLocalityDefault creates a new instance of the seller handler
func NewLocalityDefault(sv internal.LocalityService) *LocalityDefault <span class="cov8" title="1">{
        return &amp;LocalityDefault{
                sv: sv,
        }
}</span>

// LocalityDefault is the default implementation of the seller handler
type LocalityDefault struct {
        // sv is the service used by the handler
        sv internal.LocalityService
}

type LocalityGetJSON struct {
        ID           int    `json:"id"`
        LocalityName string `json:"locality_name"`
        ProvinceName string `json:"province_name"`
        CountryName  string `json:"country_name"`
        SellersCount int    `json:"sellers_count"`
}

type LocalityPostJSON struct {
        LocalityID   int    `json:"locality_id"`
        LocalityName string `json:"locality_name"`
        ProvinceName string `json:"province_name"`
        CountryName  string `json:"country_name"`
}

// ReportCarries godoc
// @Summary Report carries count per locality
// @Description Report the total number of carries for every locality or a specific one by Id
// @Tags Locality
// @Accept json
// @Produce json
// @Param id query string false "Locality ID" Format(int)
// @Success 200 {object} map[string]any "Carries report data"
// @Failure 400 {object} rest_err.RestErr "Id should be a number"
// @Failure 404 {object} rest_err.RestErr "Not carries on locality_id"
// @Failure 500 {object} rest_err.RestErr "Failed to fetch carries"
// @Router /api/v1/localities/report-carries [get]
func (h *LocalityDefault) ReportCarries() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                idStr := r.URL.Query().Get("id")

                if idStr == "" </span><span class="cov8" title="1">{
                        carries, err := h.sv.GetAmountOfCarriesForEveryLocality()
                        if err != nil </span><span class="cov0" title="0">{
                                response.JSON(
                                        w,
                                        http.StatusInternalServerError,
                                        resterr.NewInternalServerError("failed to fetch carries"),
                                )

                                return
                        }</span>

                        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                                "data": carries,
                        })

                        return</span>
                }

                <span class="cov8" title="1">id, err := strconv.Atoi(idStr)
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(
                                w,
                                http.StatusBadRequest,
                                resterr.NewBadRequestError("id should be a number"),
                        )

                        return
                }</span>

                <span class="cov8" title="1">amountOfCarries, err := h.sv.ReportCarries(id)
                if err != nil </span><span class="cov8" title="1">{
                        response.JSON(
                                w,
                                http.StatusNotFound,
                                resterr.NewNotFoundError("not carries on locality_id "+idStr),
                        )

                        return
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": struct {
                                AmountOfCarries int `json:"amount_of_carries"`
                        }{
                                AmountOfCarries: amountOfCarries,
                        },
                })</span>
        }
}

// ReportSellers godoc
// @Summary Report sellers count per locality
// @Description Report the sellers count for every locality or a specific one by Id
// @Tags Locality
// @Accept json
// @Produce json
// @Param id query string false "Locality ID" Format(int)
// @Success 200 {object} map[string]any "Sellers count report data"
// @Failure 400 {object} rest_err.RestErr "Id should be a number"
// @Failure 404 {object} rest_err.RestErr "Locality not found"
// @Failure 500 {object} rest_err.RestErr "Internal server error"
// @Router /api/v1/localities/report-sellers [get]
func (h *LocalityDefault) ReportSellers() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var localities []internal.Locality

                var err error

                idStr := r.URL.Query().Get("id")
                switch idStr </span>{
                case "":<span class="cov8" title="1">
                        localities, err = h.sv.ReportSellers()</span>
                default:<span class="cov8" title="1">
                        id, parseErr := strconv.Atoi(idStr)

                        if parseErr != nil </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError("id should be a number"))

                                return
                        }</span>

                        <span class="cov8" title="1">localities, err = h.sv.ReportSellersByID(id)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        logger.Error(err.Error(), err,
                                zap.String("id", idStr),
                        )

                        if errors.Is(err, internal.ErrLocalityNotFound) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                        return</span>
                }

                <span class="cov8" title="1">var localitiesJSON []LocalityGetJSON
                for _, locality := range localities </span><span class="cov8" title="1">{
                        localitiesJSON = append(localitiesJSON, LocalityGetJSON{
                                ID:           locality.ID,
                                LocalityName: locality.LocalityName,
                                ProvinceName: locality.ProvinceName,
                                CountryName:  locality.CountryName,
                                SellersCount: locality.Sellers,
                        })
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": localitiesJSON,
                })</span>
        }
}

// Save godoc
// @Summary Save a locality
// @Description Save a new locality on the database
// @Tags Locality
// @Accept json
// @Produce json
// @Param locality body LocalityPostJson true "Locality data"
// @Success 200 {object} map[string]any "Saved locality data"
// @Failure 400 {object} rest_err.RestErr "Locality inputs are Invalid"
// @Failure 409 {object} rest_err.RestErr "Locality conflict"
// @Failure 500 {object} rest_err.RestErr "Internal server error"
// @Router /api/v1/localities [post]
func (h *LocalityDefault) Save() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var localityJSON LocalityPostJSON

                err := json.NewDecoder(r.Body).Decode(&amp;localityJSON)
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusBadRequest, nil)

                        return
                }</span>

                <span class="cov8" title="1">locality := &amp;internal.Locality{
                        ID:           localityJSON.LocalityID,
                        LocalityName: localityJSON.LocalityName,
                        ProvinceName: localityJSON.ProvinceName,
                        CountryName:  localityJSON.CountryName,
                }

                err = h.sv.Save(locality)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, internal.ErrLocalityConflict) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">if errors.As(err, &amp;internal.DomainError{}) </span><span class="cov8" title="1">{
                                var domainError internal.DomainError

                                errors.As(err, &amp;domainError)

                                var restCauses []resterr.Causes
                                for _, cause := range domainError.Causes </span><span class="cov8" title="1">{
                                        restCauses = append(restCauses, resterr.Causes{
                                                Field:   cause.Field,
                                                Message: cause.Message,
                                        })
                                }</span>

                                <span class="cov8" title="1">response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestValidationError(domainError.Message, restCauses))

                                return</span>
                        }

                        <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                        return</span>
                }

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": localityJSON,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/service"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

type ProductHandlerDefault struct {
        s internal.ProductService
}

func NewProducHandlerDefault(phd internal.ProductService) *ProductHandlerDefault <span class="cov0" title="0">{
        return &amp;ProductHandlerDefault{s: phd}
}</span>

// GetAll godoc
// @Summary Get all products
// @Description Retrieves a list of all products in the database
// @Tags Product
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "List of all products"
// @Failure 400 {object} rest_err.RestErr "Bad request"
// @Router /api/v1/products [get]
func (h *ProductHandlerDefault) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        products, err := h.s.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": products,
        })</span>
}

// GetByID godoc
// @Summary Get product by ID
// @Description Retrieves a single product by its Id
// @Tags Product
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} map[string]any "Product data"
// @Failure 400 {object} rest_err.RestErr "Invalid Id format"
// @Failure 404 {object} rest_err.RestErr "Product not found"
// @Router /api/v1/products/{id} [get]
func (h *ProductHandlerDefault) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := strconv.Atoi(idStr)

        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">product, err := h.s.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": product,
        })</span>
}

// Create godoc
// @Summary Create a new product
// @Description Adds a new product to the system with the provided details in the request body
// @Tags Product
// @Accept json
// @Produce json
// @Param product body internal.Product true "Product data"
// @Success 201 {object} map[string]any "Product created"
// @Failure 400 {object} rest_err.RestErr "Invalid request body"
// @Failure 404 {object} rest_err.RestErr "Seller or Product Type not exists"
// @Failure 409 {object} rest_err.RestErr "Product code already exists"
// @Failure 422 {object} rest_err.RestErr "Unprocessable entity"
// @Failure 500 {object} rest_err.RestErr "Internal server error"
// @Router /api/v1/products [post]
func (h *ProductHandlerDefault) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var product internal.Product
        if err := json.NewDecoder(r.Body).Decode(&amp;product); err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">newProduct, err := h.s.Create(product)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrSellerNotExists) || errors.Is(err, service.ErrProductTypeNotExists) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))
                }</span> else<span class="cov0" title="0"> if errors.Is(err, service.ErrProductCodeAlreadyExists) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span> else<span class="cov0" title="0"> if errors.Is(err, service.ErrProductUnprocessableEntity) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(err.Error()))
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">var productJSON internal.ProductJSONPost
        productJSON.ProductCode = newProduct.ProductCode
        productJSON.Description = newProduct.Description
        productJSON.Height = newProduct.Height
        productJSON.Length = newProduct.Length
        productJSON.NetWeight = newProduct.NetWeight
        productJSON.ExpirationRate = newProduct.ExpirationRate
        productJSON.RecommendedFreezingTemperature = newProduct.RecommendedFreezingTemperature
        productJSON.Width = newProduct.Width
        productJSON.FreezingRate = newProduct.FreezingRate
        productJSON.ProductTypeID = newProduct.ProductTypeID
        productJSON.SellerID = newProduct.SellerID

        response.JSON(w, http.StatusCreated, map[string]any{
                "data": productJSON,
        })</span>
}

// Update godoc
// @Summary Update a product
// @Description Updates an existing product's data in the request body
// @Tags Product
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Param product body internal.Product true "Updated product data"
// @Success 200 {object} map[string]any "Updated product"
// @Failure 400 {object} rest_err.RestErr "Invalid request body"
// @Failure 404 {object} rest_err.RestErr "Seller or Product Type not exists"
// @Failure 409 {object} rest_err.RestErr "Product code already exists"
// @Failure 422 {object} rest_err.RestErr "All fields must be valid and filled"
// @Failure 500 {object} rest_err.RestErr "Internal server error"
// @Router /api/v1/products/{id} [patch]
func (h *ProductHandlerDefault) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := strconv.Atoi(idStr)

        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">var product internal.Product
        if err := json.NewDecoder(r.Body).Decode(&amp;product); err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">product.ID = id

        updatedProduct, err := h.s.Update(product)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrSellerNotExists) || errors.Is(err, service.ErrProductTypeNotExists) || errors.Is(err, service.ErrProductNotExists) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))
                }</span> else<span class="cov0" title="0"> if errors.Is(err, service.ErrProductCodeAlreadyExists) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span> else<span class="cov0" title="0"> if errors.Is(err, service.ErrProductUnprocessableEntity) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(err.Error()))
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": updatedProduct,
        })</span>
}

// Delete godoc
// @Summary Delete a product
// @Description Deletes a product by its Id
// @Tags Product
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Success 204 {object} nil "No content"
// @Failure 400 {object} rest_err.RestErr "Invalid Id format"
// @Failure 404 {object} rest_err.RestErr "Product not found"
// @Failure 500 {object} rest_err.RestErr "Internal server error"
// @Router /api/v1/products/{id} [delete]
func (h *ProductHandlerDefault) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")

        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">if err := h.s.Delete(id); err != nil </span><span class="cov0" title="0">{
                if err.Error() == "product not found" </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError("product not found"))

                        return
                }</span>

                <span class="cov0" title="0">response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(err.Error()))

                return</span>
        }

        <span class="cov0" title="0">response.JSON(w, http.StatusNoContent, nil)</span>
}

// ReportRecords godoc
// @Summary Get product records
// @Description Retrieves records of products, or a specific record by product Id
// @Tags Product
// @Accept json
// @Produce json
// @Param id query int false "Product ID"
// @Success 200 {object} map[string]interface{} "Product records"
// @Failure 400 {object} rest_err.RestErr "Invalid Id"
// @Failure 404 {object} rest_err.RestErr "Product not found"
// @Router /api/v1/products/report-records [get]
func (h *ProductHandlerDefault) ReportRecords(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extrair o parmetro "id" da URL
        id := r.URL.Query().Get("id")

        if id != "" </span><span class="cov0" title="0">{
                productID, err := strconv.Atoi(id)
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusBadRequest, "ID invlido")

                        return
                }</span>

                <span class="cov0" title="0">report, err := h.s.GetByIDRecord(productID)
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError("product not found"))

                        return
                }</span>

                // Retorna o relatrio
                <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                        "data": report,
                })

                return</span>
        }

        <span class="cov0" title="0">report, err := h.s.GetAllRecord()
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": report,
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

func NewHandlerProductBatch(svc internal.ProductBatchService) *ProductBatchHandler <span class="cov0" title="0">{
        return &amp;ProductBatchHandler{
                sv: svc,
        }
}</span>

type ProductBatchHandler struct {
        sv internal.ProductBatchService
}

type RequestProductBatchJSON struct {
        BatchNumber        int     `json:"batch_number"`
        CurrentQuantity    int     `json:"current_quantity"`
        CurrentTemperature float64 `json:"current_temperature"`
        DueDate            string  `json:"due_date"`
        InitialQuantity    int     `json:"initial_quantity"`
        ManufacturingDate  string  `json:"manufacturing_date"`
        ManufacturingHour  int     `json:"manufacturing_hour"`
        MinumumTemperature float64 `json:"minumum_temperature"`
        ProductID          int     `json:"product_id"`
        SectionID          int     `json:"section_id"`
}

// GetByID godoc
// @Summary Get product batch by Id
// @Description Fetch the details of a product batch using its unique Id
// @Tags ProductBatch
// @Accept json
// @Produce json
// @Param id path int true "Product Batch ID"
// @Success 200 {object} map[string]any "Product batch data"
// @Failure 400 {object} rest_err.RestErr "Invalid Id format"
// @Failure 404 {object} rest_err.RestErr "Product-batch not found"
// @Router /api/v1/product_batches/{id} [get]
func (h *ProductBatchHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">var prodBatch internal.ProductBatch

        prodBatch, err = h.sv.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": prodBatch,
        })</span>
}

// Create godoc
// @Summary Create a new product batch
// @Description Create a new product batch on the database
// @Tags ProductBatch
// @Accept json
// @Produce json
// @Param product_batch body RequestProductBatchJSON true "Product batch details"
// @Success 201 {object} map[string]any "Created product batch"
// @Failure 400 {object} rest_err.RestErr "Invalid input format"
// @Failure 409 {object} rest_err.RestErr "Product-batch with given product-batch number already registered" or "Product-batch already exists"
// @Failure 422 {object} rest_err.RestErr "Couldn't parse product-batch"
// @Router /api/v1/product_batches [post]
func (h *ProductBatchHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var prodBatchJSON RequestProductBatchJSON
        if err := json.NewDecoder(r.Body).Decode(&amp;prodBatchJSON); err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov0" title="0">prodBatch := internal.ProductBatch{
                BatchNumber:        prodBatchJSON.BatchNumber,
                CurrentQuantity:    prodBatchJSON.CurrentQuantity,
                CurrentTemperature: prodBatchJSON.CurrentTemperature,
                DueDate:            prodBatchJSON.DueDate,
                InitialQuantity:    prodBatchJSON.InitialQuantity,
                ManufacturingDate:  prodBatchJSON.ManufacturingDate,
                ManufacturingHour:  prodBatchJSON.ManufacturingHour,
                MinumumTemperature: prodBatchJSON.MinumumTemperature,
                ProductID:          prodBatchJSON.ProductID,
                SectionID:          prodBatchJSON.SectionID,
        }

        err := h.sv.Save(&amp;prodBatch)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, internal.ErrProductBatchNumberAlreadyInUse) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.JSON(w, http.StatusCreated, map[string]any{
                "data": prodBatch,
        })</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/bootcamp-go/web/response"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/service"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

type ProductRecordsHandlerDefault struct {
        pd internal.ProductRecordsService
}

// NewProductRecordsDefault creates a new instance of ProductRecordsHandlerDefault.
func NewProductRecordsDefault(pd internal.ProductRecordsService) *ProductRecordsHandlerDefault <span class="cov0" title="0">{
        return &amp;ProductRecordsHandlerDefault{
                pd: pd,
        }
}</span>


// Create handles the creation of a Product Record.
// Create godoc
// @Summary Create a product record
// @Description Creates a new product record with details on the database.
// @Tags ProductRecords
// @Accept json
// @Produce json
// @Param product_record body internal.ProductRecords true "Product Record Data"
// @Success 201 {object} map[string]interface{} "Created product record"
// @Failure 422 {object} rest_err.RestErr "Invalid JSON"
// @Failure 409 {object} rest_err.RestErr "Error ID doesn't exists"
// @Router /api/v1/productRecords [post]
func (h *ProductRecordsHandlerDefault) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var productRec internal.ProductRecords

        // Decodifica o corpo da requisio JSON
        if err := json.NewDecoder(r.Body).Decode(&amp;productRec); err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusUnprocessableEntity, "JSON invlido")

                return
        }</span>

        // Chama o servio para criar o registro
        <span class="cov0" title="0">createdProductRec, err := h.pd.Create(productRec)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrProductUnprocessableEntity) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                }</span>

                <span class="cov0" title="0">if errors.Is(err, service.ErrProductNotExists) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">productRecJSON := internal.ProductRecordsJSON{
                LastUpdateDate: createdProductRec.LastUpdateDate,
                PurchasePrice:  createdProductRec.PurchasePrice,
                SalePrice:      createdProductRec.SalePrice,
                ProductID:      createdProductRec.ProductID,
        }
        // Retorna o registro criado com status 201
        response.JSON(w, http.StatusCreated, map[string]any{
                "data": productRecJSON,
        })</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"
        "time"

        "github.com/bootcamp-go/web/response"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/service"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

// PurchaseOrderJSON is a struct that represents a purchase order in JSON format
type PurchaseOrderJSON struct {
        ID              int    `json:"id"`
        OrderNumber     string `json:"order_number"`
        OrderDate       string `json:"order_date"`
        TrackingCode    string `json:"tracking_code"`
        BuyerID         int    `json:"buyer_id"`
        ProductRecordID int    `json:"product_record_id"`
}

// PurchaseOrderCreateRequest is a struct that represents a purchase order create request
type PurchaseOrderCreateRequest struct {
        OrderNumber     string `json:"order_number"`
        OrderDate       string `json:"order_date"`
        TrackingCode    string `json:"tracking_code"`
        BuyerID         int    `json:"buyer_id"`
        ProductRecordID int    `json:"product_record_id"`
}

// NewPurchaseOrderHandler creates a new instance of the purchase order handler
func NewPurchaseOrderHandler(sv internal.PurchaseOrderService) *PurchaseOrderHandler <span class="cov8" title="1">{
        return &amp;PurchaseOrderHandler{
                sv: sv,
        }
}</span>

// PurchaseOrderHandler is the default implementation of the purchase order handler
type PurchaseOrderHandler struct {
        sv internal.PurchaseOrderService
}

// Create creates a new purchase order
// @Summary Create a new purchase order
// @Description Handles the creation of a new purchase order to the database
// @Tags PurchaseOrder
// @Accept json
// @Produce json
// @Param request body handler.PurchaseOrderCreateRequest true "Purchase Order Create Request"
// @Success 201 {object} handler.PurchaseOrderJSON "Created Purchase Order"
// @Failure 400 {object} rest_err.RestErr "Invalid data"
// @Failure 422 {object} rest_err.RestErr "Purchase Order inputs are Invalid"
// @Failure 404 {object} rest_err.RestErr "Product records or Buyer not found"
// @Failure 409 {object} rest_err.RestErr "Purchase order number already exists"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/purchase-orders [post]
func (h *PurchaseOrderHandler) Create() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var requestInput *PurchaseOrderCreateRequest

                // decoding the request
                if err := json.NewDecoder(r.Body).Decode(&amp;requestInput); err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                        return
                }</span>

                // validating the orderDate field
                <span class="cov8" title="1">orderDate, err := time.Parse(time.DateOnly, requestInput.OrderDate)
                if err != nil </span><span class="cov8" title="1">{
                        var causes []resterr.Causes

                        causes = append(causes, resterr.Causes{
                                Field:   "order_date",
                                Message: "invalid date format",
                        })

                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestValidationError(ErrInvalidData, causes))

                        return
                }</span>

                // creating the purchase order
                <span class="cov8" title="1">purchaseOrder := &amp;internal.PurchaseOrder{
                        ID:              0,
                        OrderNumber:     requestInput.OrderNumber,
                        OrderDate:       orderDate,
                        TrackingCode:    requestInput.TrackingCode,
                        BuyerID:         requestInput.BuyerID,
                        ProductRecordID: requestInput.ProductRecordID,
                }

                // saving the purchase order
                if err := h.sv.Save(purchaseOrder); err != nil </span><span class="cov8" title="1">{
                        switch </span>{
                        case errors.As(err, &amp;internal.DomainError{}):<span class="cov8" title="1">
                                var domainError internal.DomainError

                                errors.As(err, &amp;domainError)

                                var restCauses []resterr.Causes
                                for _, cause := range domainError.Causes </span><span class="cov8" title="1">{
                                        restCauses = append(restCauses, resterr.Causes{
                                                Field:   cause.Field,
                                                Message: cause.Message,
                                        })
                                }</span>

                                <span class="cov8" title="1">response.JSON(w, http.StatusUnprocessableEntity, resterr.NewBadRequestValidationError(domainError.Message, restCauses))</span>
                        case errors.Is(err, internal.ErrPurchaseOrderConflict):<span class="cov8" title="1">
                                response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))</span>
                        case errors.Is(err, service.ErrProductRecordsNotFound):<span class="cov8" title="1">
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))</span>
                        case errors.Is(err, service.ErrBuyerNotFound):<span class="cov8" title="1">
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))</span>
                        default:<span class="cov0" title="0">
                                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(ErrInternalServer))</span>
                        }

                        <span class="cov8" title="1">return</span>
                }

                // creating the response
                <span class="cov8" title="1">purchaseOrderJSON := &amp;PurchaseOrderJSON{
                        ID:              purchaseOrder.ID,
                        OrderNumber:     purchaseOrder.OrderNumber,
                        OrderDate:       purchaseOrder.OrderDate.Format(time.DateOnly),
                        TrackingCode:    purchaseOrder.TrackingCode,
                        BuyerID:         purchaseOrder.BuyerID,
                        ProductRecordID: purchaseOrder.ProductRecordID,
                }

                // sending the response
                response.JSON(w, http.StatusCreated, map[string]any{
                        "data": purchaseOrderJSON,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "log"
        "net/http"
        "strconv"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

type RequestSectionJSON struct {
        SectionNumber      int     `json:"section_number"`
        CurrentTemperature float64 `json:"current_temperature"`
        MinimumTemperature float64 `json:"minimum_temperature"`
        CurrentCapacity    int     `json:"current_capacity"`
        MinimumCapacity    int     `json:"minimum_capacity"`
        MaximumCapacity    int     `json:"maximum_capacity"`
        WarehouseID        int     `json:"warehouse_id"`
        ProductTypeID      int     `json:"product_type_id"`
}

type SectionsUpdateJSON struct {
        SectionNumber      *int     `json:"section_number"`
        CurrentTemperature *float64 `json:"current_temperature"`
        MinimumTemperature *float64 `json:"minimum_temperature"`
        CurrentCapacity    *int     `json:"current_capacity"`
        MinimumCapacity    *int     `json:"minimum_capacity"`
        MaximumCapacity    *int     `json:"maximum_capacity"`
        WarehouseID        *int     `json:"warehouse_id"`
        ProductTypeID      *int     `json:"product_type_id"`
}

type ResponseReportProd struct {
        SectionID     int `json:"section_id"`
        SectionNumber int `json:"section_number"`
        ProductsCount int `json:"products_count"`
}

func NewHandlerSection(svc internal.SectionService) *SectionHandler <span class="cov8" title="1">{
        return &amp;SectionHandler{
                sv: svc,
        }
}</span>

type SectionHandler struct {
        sv internal.SectionService
}

// GetAll retrieves all sections
// @Summary Retrieve all sections
// @Description Fetches all sections available in the database
// @Tags Section
// @Produce json
// @Success 200 {object} []internal.Section "List of sections"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Router /api/v1/sections [get]
func (h *SectionHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        sections, err := h.sv.FindAll()
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, internal.ErrSectionNotFound) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError("section not found"))

                        return
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": sections,
        })</span>
}

// GetByID retrieves a section by ID
// @Summary Retrieve a section by ID
// @Description Fetches the section based on the provided section ID
// @Tags Section
// @Produce json
// @Param id path int true "Section ID"
// @Success 200 {object} internal.Section "Section data"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 404 {object} rest_err.RestErr "Section not found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sections/{id} [get]
func (h *SectionHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))

                return
        }</span>

        <span class="cov8" title="1">var section internal.Section

        section, err = h.sv.FindByID(id)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, internal.ErrSectionNotFound) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                        return
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": section,
        })</span>
}

// ReportProducts retrieves a report of products for all sections or a specific section
// @Summary Retrieve a report of products in a section
// @Description Fetches a report of products available in a section or across all sections
// @Tags Section
// @Produce json
// @Param id query int false "Section ID"
// @Success 200 {object} []ResponseReportProd "Report of products in sections"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 404 {object} rest_err.RestErr "Section not found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sections/report-products [get]
func (h *SectionHandler) ReportProducts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        idStr := r.URL.Query().Get("id")

        if idStr == "" </span><span class="cov8" title="1">{
                sections, err := h.sv.ReportProducts()
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(err.Error()))
                        return
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": sections,
                })

                return</span>
        }

        <span class="cov0" title="0">idSection, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">report, err := h.sv.ReportProductsByID(idSection)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)

                if errors.Is(err, internal.ErrSectionNotFound) </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(err.Error()))
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, map[string]any{
                "data": report,
        })</span>
}

// Create creates a new section
// @Summary Create a new section
// @Description Creates a new section with the provided details on the request body
// @Tags Section
// @Accept json
// @Produce json
// @Param section body RequestSectionJSON true "Section Create Request"
// @Success 201 {object} internal.Section "Created Section"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 409 {object} rest_err.RestErr "Section with given section number already registered" or "Warehouse not found" or "Product-type not found"
// @Failure 422 {object} rest_err.RestErr "Couldn't parse section"
// @Router /api/v1/sections [post]
func (h *SectionHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var sectionJSON map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;sectionJSON); err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">requiredFields := []string{
                "section_number", "current_temperature", "minimum_temperature",
                "current_capacity", "minimum_capacity", "maximum_capacity",
                "warehouse_id", "product_type_id",
        }

        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if sectionJSON[field] == nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(field+" is required"))
                        return
                }</span>
        }

        <span class="cov8" title="1">section := internal.Section{
                SectionNumber:      int(sectionJSON["section_number"].(float64)),
                CurrentTemperature: sectionJSON["current_temperature"].(float64),
                MinimumTemperature: sectionJSON["minimum_temperature"].(float64),
                CurrentCapacity:    int(sectionJSON["current_capacity"].(float64)),
                MinimumCapacity:    int(sectionJSON["minimum_capacity"].(float64)),
                MaximumCapacity:    int(sectionJSON["maximum_capacity"].(float64)),
                WarehouseID:        int(sectionJSON["warehouse_id"].(float64)),
                ProductTypeID:      int(sectionJSON["product_type_id"].(float64)),
        }

        err := h.sv.Save(&amp;section)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, internal.ErrSectionAlreadyExists) || errors.Is(err, internal.ErrSectionNumberAlreadyInUse) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span> else<span class="cov8" title="1"> {
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                }</span>

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusCreated, map[string]any{
                "data": section,
        })</span>
}

// Update updates an existing section
// @Summary Update an existing section
// @Description Updates a section with the provided Id and data on the request body
// @Tags Section
// @Accept json
// @Produce json
// @Param id path int true "Section ID"
// @Param updates body map[string]interface{} true "Updated section data"
// @Success 200 {object} internal.Section "Updated Section"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 404 {object} rest_err.RestErr "Section not found"
// @Failure 409 {object} rest_err.RestErr "Section with given section number already registered"
// @Router /api/v1/sections/{id} [patch]
func (h *SectionHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">var body SectionsUpdateJSON
        if err = json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">stPatch := internal.SectionPatch{
                SectionNumber:      body.SectionNumber,
                CurrentTemperature: body.CurrentTemperature,
                MinimumTemperature: body.MinimumTemperature,
                CurrentCapacity:    body.CurrentCapacity,
                MinimumCapacity:    body.MinimumCapacity,
                MaximumCapacity:    body.MaximumCapacity,
                WarehouseID:        body.WarehouseID,
                ProductTypeID:      body.ProductTypeID,
        }

        section, err := h.sv.Update(id, stPatch)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, internal.ErrSectionNotFound) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))
                }</span> else<span class="cov8" title="1"> if errors.Is(err, internal.ErrSectionUnprocessableEntity) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                }</span> else<span class="cov8" title="1"> if errors.Is(err, internal.ErrSectionNumberAlreadyInUse) </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                "data": section,
        })</span>
}

// Delete deletes a section
// @Summary Delete a section
// @Description Deletes a section identified by its Id
// @Tags Section
// @Produce json
// @Param id path int true "Section ID"
// @Success 204 {object} nil "No Content"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 404 {object} rest_err.RestErr "Section not found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sections/{id} [delete]
func (h *SectionHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id, err := strconv.Atoi(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov8" title="1">{
                response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">err = h.sv.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, internal.ErrSectionNotFound):<span class="cov8" title="1">
                        response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))</span>
                default:<span class="cov8" title="1">
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(ErrInternalServer))</span>
                }

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">response.JSON(w, http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handler

import (
        "errors"
        "log"
        "net/http"
        "strconv"

        "github.com/bootcamp-go/web/request"
        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

// NewSellerDefault creates a new instance of the seller handler
func NewSellerDefault(sv internal.SellerService) *SellerDefault <span class="cov8" title="1">{
        return &amp;SellerDefault{
                sv: sv,
        }
}</span>

// SellerDefault is the default implementation of the seller handler
type SellerDefault struct {
        // sv is the service used by the handler
        sv internal.SellerService
}

type SellersGetJSON struct {
        ID          int    `json:"id"`
        CID         int    `json:"cid"`
        CompanyName string `json:"company_name"`
        Address     string `json:"address"`
        Telephone   string `json:"telephone"`
        Locality    int    `json:"locality_id"`
}

type SellersPostJSON struct {
        CID         int    `json:"cid"`
        CompanyName string `json:"company_name"`
        Address     string `json:"address"`
        Telephone   string `json:"telephone"`
        Locality    int    `json:"locality_id"`
}

type SellersUpdateJSON struct {
        CID         *int    `json:"cid"`
        CompanyName *string `json:"company_name"`
        Address     *string `json:"address"`
        Telephone   *string `json:"telephone"`
        Locality    *int    `json:"locality_id"`
}

// GetAll returns all sellers
// @Summary Retrieve all sellers
// @Description Fetches a list of all sellers in the database
// @Tags Seller
// @Produce json
// @Success 200 {object} []SellersGetJson "List of sellers"
// @Failure 404 {object} rest_err.RestErr "Sellers not found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sellers [get]
func (h *SellerDefault) GetAll() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                all, err := h.sv.FindAll()
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, internal.ErrSellerNotFound) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError("sellers not found"))

                                return
                        }</span>

                        <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                        return</span>
                }

                <span class="cov8" title="1">var sellerJSON []SellersGetJSON
                for i := range all </span><span class="cov8" title="1">{
                        sellerJSON = append(sellerJSON, SellersGetJSON{
                                ID:          all[i].ID,
                                CID:         all[i].CID,
                                CompanyName: all[i].CompanyName,
                                Address:     all[i].Address,
                                Telephone:   all[i].Telephone,
                        })
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": sellerJSON,
                })</span>
        }
}

// GetByID returns a seller by ID
// @Summary Retrieve a seller by ID
// @Description Fetches a seller's details based on the provided ID
// @Tags Seller
// @Produce json
// @Param id path int true "Seller ID"
// @Success 200 {object} SellersGetJson "Seller data"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 404 {object} rest_err.RestErr "Seller Not Found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sellers/{id} [get]
func (h *SellerDefault) GetByID() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                idStr := chi.URLParam(r, "id")

                id, err := strconv.Atoi(idStr)
                if err != nil </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusBadRequest, nil)

                        return
                }</span>

                <span class="cov8" title="1">seller, err := h.sv.FindByID(id)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, internal.ErrSellerNotFound) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                        return</span>
                }

                <span class="cov8" title="1">var sellerJSON = SellersGetJSON{
                        ID:          seller.ID,
                        CID:         seller.CID,
                        CompanyName: seller.CompanyName,
                        Address:     seller.Address,
                        Telephone:   seller.Telephone,
                        Locality:    seller.Locality,
                }

                response.JSON(w, http.StatusOK, map[string]any{
                        "data": sellerJSON,
                })</span>
        }
}

// Save creates a new seller
// @Summary Create a new seller
// @Description Adds a new seller to the system with the provided details on the request body.
// @Tags Seller
// @Accept json
// @Produce json
// @Param seller body SellersPostJson true "Seller Create Request"
// @Success 201 {object} map[string]interface{} "Created Seller Id"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 404 {object} rest_err.RestErr "Seller not found" or "Locality not found"
// @Failure 409 {object} rest_err.RestErr "Seller already exists" or "Seller with this CID already exists"
// @Failure 422 {object} rest_err.RestErr "Unprocessable Entity"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sellers [post]
func (h *SellerDefault) Save() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var body SellersPostJSON

                err := request.JSON(r, &amp;body)
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusInternalServerError, nil)

                        return
                }</span>

                <span class="cov8" title="1">sl := &amp;internal.Seller{
                        CID:         body.CID,
                        CompanyName: body.CompanyName,
                        Address:     body.Address,
                        Telephone:   body.Telephone,
                        Locality:    body.Locality,
                }

                err = sl.Validate()
                if err != nil </span><span class="cov8" title="1">{
                        restErr := resterr.NewUnprocessableEntityError(err.Error())
                        response.JSON(w, restErr.Code, restErr)

                        return
                }</span>

                <span class="cov8" title="1">err = h.sv.Save(sl)
                if err != nil </span><span class="cov8" title="1">{
                        log.Println(err)

                        if errors.Is(err, internal.ErrSellerConflict) || errors.Is(err, internal.ErrSellerCIDAlreadyExists) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">if errors.Is(err, internal.ErrSellerNotFound) || errors.Is(err, internal.ErrLocalityNotFound) </span><span class="cov0" title="0">{
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                        return</span>
                }

                <span class="cov8" title="1">response.JSON(w, http.StatusCreated, map[string]any{
                        "data": map[string]any{
                                "seller_id": sl.ID,
                        },
                })</span>
        }
}

// Update updates a seller's details
// @Summary Update seller details
// @Description Modify the information of an existing seller
// @Tags Seller
// @Accept json
// @Produce json
// @Param id path int true "Seller ID"
// @Param seller body SellersUpdateJson true "Seller Update Request"
// @Success 200 {object} SellersGetJson "Updated Seller data"
// @Failure 400 {object} rest_err.RestErr "Seller invalid fields"
// @Failure 404 {object} rest_err.RestErr "Seller not found"
// @Failure 409 {object} rest_err.RestErr "Seller with this CID already exists"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sellers/{id} [patch]
func (h *SellerDefault) Update() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                idStr := chi.URLParam(r, "id")

                id, err := strconv.Atoi(idStr)
                if err != nil </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusBadRequest, nil)

                        return
                }</span>

                <span class="cov8" title="1">var body SellersUpdateJSON

                err = request.JSON(r, &amp;body)
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusInternalServerError, nil)

                        return
                }</span>

                <span class="cov8" title="1">slPatch := internal.SellerPatch{
                        CID:         body.CID,
                        CompanyName: body.CompanyName,
                        Address:     body.Address,
                        Telephone:   body.Telephone,
                        Locality:    body.Locality,
                }

                seller, err := h.sv.Update(id, slPatch)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, internal.ErrSellerCIDAlreadyExists) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">if errors.Is(err, internal.ErrSellerInvalidFields) </span><span class="cov8" title="1">{
                                restErr := resterr.NewBadRequestError(err.Error())
                                response.JSON(w, restErr.Code, restErr)

                                return
                        }</span>

                        <span class="cov8" title="1">if errors.Is(err, internal.ErrSellerNotFound) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                        return</span>
                }

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": SellersGetJSON{
                                ID:          seller.ID,
                                CID:         seller.CID,
                                CompanyName: seller.CompanyName,
                                Address:     seller.Address,
                                Telephone:   seller.Telephone,
                                Locality:    seller.Locality,
                        },
                })</span>
        }
}

// Delete deletes a seller
// @Summary Delete a seller
// @Description Removes a seller from the system based on the provided Id
// @Tags Seller
// @Produce json
// @Param id path int true "Seller ID"
// @Success 204 {object} nil "No Content"
// @Failure 400 {object} rest_err.RestErr "Bad Request"
// @Failure 404 {object} rest_err.RestErr "Seller not found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/sellers/{id} [delete]
func (h *SellerDefault) Delete() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                idStr := chi.URLParam(r, "id")

                id, err := strconv.Atoi(idStr)
                if err != nil </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusBadRequest, nil)

                        return
                }</span>

                <span class="cov8" title="1">err = h.sv.Delete(id)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, internal.ErrSellerNotFound) </span><span class="cov8" title="1">{
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))

                                return
                        }</span>

                        <span class="cov8" title="1">response.JSON(w, http.StatusInternalServerError, nil)

                        return</span>
                }

                <span class="cov8" title="1">response.JSON(w, http.StatusNoContent, nil)</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handler

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/utils/resterr"
)

// WarehouseJSON represents the warehouse in JSON format.
type WarehouseJSON struct {
        ID                 int     `json:"id"`
        WarehouseCode      string  `json:"warehouse_code"`
        Address            string  `json:"address"`
        Telephone          string  `json:"telephone"`
        MinimumCapacity    int     `json:"minimum_capacity"`
        MinimumTemperature float64 `json:"minimum_temperature"`
}

type WarehouseCreateRequest struct {
        WarehouseCode      string  `json:"warehouse_code"`
        Address            string  `json:"address"`
        Telephone          string  `json:"telephone"`
        MinimumCapacity    int     `json:"minimum_capacity"`
        MinimumTemperature float64 `json:"minimum_temperature"`
}

var (
        ErrInternalServer = "Internal Server Error"
        ErrInvalidID      = "Invalid ID format"
        ErrInvalidData    = "Invalid data"
)

// NewWarehouseDefault Builder creates a new instance of the warehouse handler
func NewWarehouseDefault(sv internal.WarehouseService) *WarehouseDefault <span class="cov8" title="1">{
        return &amp;WarehouseDefault{
                sv: sv,
        }
}</span>

// WarehouseDefault is the default implementation of the warehouse handler
type WarehouseDefault struct {
        // sv is the service used by the handler
        sv internal.WarehouseService
}

// GetAll returns all warehouses
// @Summary Get all warehouses
// @Description Retrieve a list of all warehouses in the database
// @Tags Warehouse
// @Produce json
// @Success 200 {object} map[string]any "List of all warehouses"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/warehouses [get]
func (h *WarehouseDefault) GetAll() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Find all warehouses
                warehouses, err := h.sv.FindAll()
                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(ErrInternalServer))
                        return
                }</span>

                // Data to be returned
                <span class="cov8" title="1">var data []WarehouseJSON
                for _, warehouse := range warehouses </span><span class="cov8" title="1">{
                        data = append(data, WarehouseJSON{
                                ID:                 warehouse.ID,
                                WarehouseCode:      warehouse.WarehouseCode,
                                Address:            warehouse.Address,
                                Telephone:          warehouse.Telephone,
                                MinimumCapacity:    warehouse.MinimumCapacity,
                                MinimumTemperature: warehouse.MinimumTemperature,
                        })
                }</span>

                <span class="cov8" title="1">response.JSON(w, http.StatusOK, map[string]any{
                        "data": data,
                })</span>
        }
}

// GetByID returns a warehouse by id
// @Summary Get warehouse by Id
// @Description Retrieve a warehouse's details by its Id
// @Tags Warehouse
// @Produce json
// @Param id path int true "Warehouse ID"
// @Success 200 {object} WarehouseJSON "Warehouse data"
// @Failure 400 {object} rest_err.RestErr "Invalid ID format"
// @Failure 404 {object} rest_err.RestErr "Warehouse not found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/warehouses/{id} [get]
func (h *WarehouseDefault) GetByID() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                id := chi.URLParam(r, "id")
                idInt, err := strconv.Atoi(id)

                if err != nil </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(ErrInvalidID))
                        return
                }</span>

                <span class="cov8" title="1">warehouse, err := h.sv.FindByID(idInt)
                if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, internal.ErrWarehouseRepositoryNotFound):<span class="cov0" title="0">
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))</span>
                        default:<span class="cov0" title="0">
                                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(ErrInternalServer))</span>
                        }

                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">warehouseJSON := WarehouseJSON{
                        ID:                 warehouse.ID,
                        WarehouseCode:      warehouse.WarehouseCode,
                        Address:            warehouse.Address,
                        Telephone:          warehouse.Telephone,
                        MinimumCapacity:    warehouse.MinimumCapacity,
                        MinimumTemperature: warehouse.MinimumTemperature,
                }

                response.JSON(w, http.StatusOK, map[string]any{
                        "data": warehouseJSON,
                })</span>
        }
}

// Create creates a new warehouse
// @Summary Create a new warehouse
// @Description Add a new warehouse to the database
// @Tags Warehouse
// @Accept json
// @Produce json
// @Param warehouse body WarehouseCreateRequest true "Warehouse data"
// @Success 201 {object} WarehouseJSON "Created warehouse"
// @Failure 400 {object} rest_err.RestErr "Invalid Data"
// @Failure 409 {object} rest_err.RestErr "Warehouse already exists"
// @Failure 422 {object} rest_err.RestErr "Unprocessable Entity"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/warehouses [post]
func (h *WarehouseDefault) Create() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var requestInput *WarehouseCreateRequest

                // decode the request
                if err := json.NewDecoder(r.Body).Decode(&amp;requestInput); err != nil </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(ErrInvalidData))
                        return
                }</span>

                // create the warehouse
                <span class="cov8" title="1">warehouse := internal.Warehouse{
                        ID:                 0,
                        WarehouseCode:      requestInput.WarehouseCode,
                        Address:            requestInput.Address,
                        Telephone:          requestInput.Telephone,
                        MinimumCapacity:    requestInput.MinimumCapacity,
                        MinimumTemperature: requestInput.MinimumTemperature,
                }

                // validating the warehouse
                if err := warehouse.Validate(); err != nil </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusUnprocessableEntity, resterr.NewUnprocessableEntityError(err.Error()))
                        return
                }</span>

                // save the warehouse
                <span class="cov8" title="1">err := h.sv.Save(&amp;warehouse)
                if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, internal.ErrWarehouseRepositoryDuplicated):<span class="cov0" title="0">
                                response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))</span>
                        default:<span class="cov0" title="0">
                                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(ErrInternalServer))</span>
                        }

                        <span class="cov0" title="0">return</span>
                }

                // return the warehouse
                <span class="cov8" title="1">warehouseJSON := WarehouseJSON{
                        ID:                 warehouse.ID,
                        WarehouseCode:      warehouse.WarehouseCode,
                        Address:            warehouse.Address,
                        Telephone:          warehouse.Telephone,
                        MinimumCapacity:    warehouse.MinimumCapacity,
                        MinimumTemperature: warehouse.MinimumTemperature,
                }

                response.JSON(w, http.StatusCreated, map[string]any{
                        "data": warehouseJSON,
                })</span>
        }
}

// Update updates a warehouse
// @Summary Update warehouse details
// @Description Modify an existing warehouse's data
// @Tags Warehouse
// @Accept json
// @Produce json
// @Param id path int true "Warehouse ID"
// @Param warehouse body internal.WarehousePatchUpdate true "Updated warehouse data"
// @Success 200 {object} WarehouseJSON "Updated warehouse"
// @Failure 400 {object} rest_err.RestErr "Invalid ID format" or "Invalid Data"
// @Failure 404 {object} rest_err.RestErr "Warehouse not found"
// @Failure 409 {object} rest_err.RestErr "Warehouse already exists"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/warehouses/{id} [patch]
func (h *WarehouseDefault) Update() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                id := chi.URLParam(r, "id")
                idInt, err := strconv.Atoi(id)

                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(ErrInvalidID))
                        return
                }</span>

                // decode the request into a WarehousePatchUpdate
                <span class="cov8" title="1">var requestInput *internal.WarehousePatchUpdate
                if err := json.NewDecoder(r.Body).Decode(&amp;requestInput); err != nil </span><span class="cov8" title="1">{
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(ErrInvalidData))
                        return
                }</span>

                // Calling the service to update the warehouse
                <span class="cov8" title="1">warehouse, err := h.sv.Update(idInt, requestInput)
                if err != nil </span><span class="cov8" title="1">{
                        switch </span>{
                        case errors.Is(err, internal.ErrWarehouseRepositoryDuplicated):<span class="cov0" title="0">
                                response.JSON(w, http.StatusConflict, resterr.NewConflictError(err.Error()))</span>
                        case errors.Is(err, internal.ErrWarehouseRepositoryNotFound):<span class="cov8" title="1">
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))</span>
                        default:<span class="cov0" title="0">
                                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(ErrInternalServer))</span>
                        }

                        <span class="cov8" title="1">return</span>
                }

                // Returning the updated warehouse
                <span class="cov8" title="1">warehouseJSON := WarehouseJSON{
                        ID:                 warehouse.ID,
                        WarehouseCode:      warehouse.WarehouseCode,
                        Address:            warehouse.Address,
                        Telephone:          warehouse.Telephone,
                        MinimumCapacity:    warehouse.MinimumCapacity,
                        MinimumTemperature: warehouse.MinimumTemperature,
                }

                response.JSON(w, http.StatusOK, map[string]any{
                        "data": warehouseJSON,
                })</span>
        }
}

// Delete deletes a warehouse
// @Summary Delete warehouse
// @Description Removes a warehouse from the database by its ID
// @Tags Warehouse
// @Param id path int true "Warehouse ID"
// @Success 204 {object} nil "No Content"
// @Failure 400 {object} rest_err.RestErr "Invalid ID format"
// @Failure 404 {object} rest_err.RestErr "Warehouse not found"
// @Failure 500 {object} rest_err.RestErr "Internal Server Error"
// @Router /api/v1/warehouses/{id} [delete]
func (h *WarehouseDefault) Delete() http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                id := chi.URLParam(r, "id")
                idInt, err := strconv.Atoi(id)

                if err != nil </span><span class="cov0" title="0">{
                        response.JSON(w, http.StatusBadRequest, resterr.NewBadRequestError(ErrInvalidID))
                        return
                }</span>

                <span class="cov8" title="1">err = h.sv.Delete(idInt)
                if err != nil </span><span class="cov8" title="1">{
                        switch </span>{
                        case errors.Is(err, internal.ErrWarehouseRepositoryNotFound):<span class="cov8" title="1">
                                response.JSON(w, http.StatusNotFound, resterr.NewNotFoundError(err.Error()))</span>
                        default:<span class="cov0" title="0">
                                response.JSON(w, http.StatusInternalServerError, resterr.NewInternalServerError(ErrInternalServer))</span>
                        }

                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">response.JSON(w, http.StatusNoContent, nil)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package internal

import "errors"

var ErrOrderNumberAlreadyExists = errors.New("order number already exists")

type InboundOrders struct {
        ID             int    `json:"id"`
        OrderDate      string `json:"order_date"`
        OrderNumber    string `json:"order_number"`
        EmployeeID     int    `json:"employee_id"`
        ProductBatchID int    `json:"product_batch_id"`
        WarehouseID    int    `json:"warehouse_id"`
}

type InboundOrderService interface {
        Create(InboundOrders) (int64, error)
        FindAll() ([]InboundOrders, error)
}

type InboundOrdersRepository interface {
        Create(InboundOrders) (int64, error)
        FindAll() ([]InboundOrders, error)
}

// ValidateFieldsOk validates required fields
func (io *InboundOrders) ValidateFieldsOk() bool <span class="cov0" title="0">{
        if io.OrderDate == "" || io.OrderNumber == "" || io.EmployeeID == 0 || io.ProductBatchID == 0 || io.WarehouseID == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package loader

import (
        "encoding/json"
        "io"
        "os"
)

const (
        localFileProdTypeJSON = "db/product_type.json"
)

type ProductType struct {
        ID          int    `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

func ReadAllProductsTypeToFile() ([]*ProductType, error) <span class="cov0" title="0">{
        var productTypeList []*ProductType

        file, err := os.Open(localFileProdTypeJSON)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        file, err = os.Create(localFileProdTypeJSON)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">defer file.Close()

                        initialData := []ProductType{}

                        writer := json.NewEncoder(file)
                        if err := writer.Encode(initialData); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return productTypeList, nil</span>
                }

                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">defer file.Close()

        reader := json.NewDecoder(file)

        err = reader.Decode(&amp;productTypeList)
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return productTypeList, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package loader

import (
        "encoding/json"
        "io"
        "os"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

const (
        localFileJSON = "db/section.json"
)

func ReadAllSectionsToFile() ([]*internal.Section, error) <span class="cov0" title="0">{
        var sectionList []*internal.Section

        file, err := os.Open(localFileJSON)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        file, err = os.Create(localFileJSON)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">defer file.Close()

                        initialData := []internal.Section{}

                        writer := json.NewEncoder(file)
                        if err := writer.Encode(initialData); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return sectionList, nil</span>
                }

                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">defer file.Close()

        reader := json.NewDecoder(file)

        err = reader.Decode(&amp;sectionList)
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return sectionList, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package internal

import (
        "errors"

        "github.com/meli-fresh-products-api-backend-t1/utils/validator"
)

type Locality struct {
        ID           int
        LocalityName string
        ProvinceName string
        CountryName  string
        Sellers      int
}

type CarriesCountPerLocality struct {
        CarriesCount int    `json:"carries_count"`
        LocalityID   int    `json:"locality_id"`
        LocalityName string `json:"locality_name"`
}

var (
        // ErrLocalityNotFound is returned when the seller is not found
        ErrLocalityNotFound = errors.New("locality not found")
        ErrLocalityConflict = errors.New("locality conflict")
)

func (l *Locality) Validate() (causes []Causes) <span class="cov8" title="1">{
        if validator.IntIsNegative(l.ID) </span><span class="cov8" title="1">{
                causes = append(causes, Causes{
                        Field:   "locality_id",
                        Message: "Locality ID cannot be negative",
                })
        }</span>

        <span class="cov8" title="1">if validator.IntIsZero(l.ID) </span><span class="cov8" title="1">{
                causes = append(causes, Causes{
                        Field:   "locality_id",
                        Message: "Locality ID is required",
                })
        }</span>

        <span class="cov8" title="1">if !validator.String(l.LocalityName, 1, 255) </span><span class="cov8" title="1">{
                causes = append(causes, Causes{
                        Field:   "locality_name",
                        Message: "Locality name is required",
                })
        }</span>

        <span class="cov8" title="1">if !validator.String(l.CountryName, 1, 255) </span><span class="cov8" title="1">{
                causes = append(causes, Causes{
                        Field:   "country_name",
                        Message: "Country name cannot be empty",
                })
        }</span>

        <span class="cov8" title="1">if !validator.String(l.ProvinceName, 1, 255) </span><span class="cov8" title="1">{
                causes = append(causes, Causes{
                        Field:   "province_name",
                        Message: "Province name cannot be empty",
                })
        }</span>

        <span class="cov8" title="1">return causes</span>
}

type LocalityRepository interface {
        Save(locality *Locality) (err error)
        ReportSellers() (localities []Locality, err error)
        ReportSellersByID(id int) (localities []Locality, err error)
        FindByID(id int) (locality Locality, err error)
        ReportCarries(localityID int) (amountOfCarries int, e error)
        GetAmountOfCarriesForEveryLocality() (c []CarriesCountPerLocality, e error)
}

type LocalityService interface {
        Save(locality *Locality) (err error)
        ReportSellers() (localities []Locality, err error)
        ReportSellersByID(id int) (localities []Locality, err error)
        FindByID(id int) (locality Locality, err error)
        ReportCarries(localityID int) (int, error)
        GetAmountOfCarriesForEveryLocality() ([]CarriesCountPerLocality, error)
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package internal

import "errors"

var (
        ErrProductBatchNotFound            = errors.New("product-batch not found")
        ErrProductBatchAlreadyExists       = errors.New("product-batch already exists")
        ErrProductBatchNumberAlreadyInUse  = errors.New("product-batch with given product-batch number already registered")
        ErrProductBatchUnprocessableEntity = errors.New("couldn't parse product-batch")
)

type ProductBatch struct {
        ID                 int     `json:"id"`
        BatchNumber        int     `json:"batch_number"`
        CurrentQuantity    int     `json:"current_quantity"`
        CurrentTemperature float64 `json:"current_temperature"`
        DueDate            string  `json:"due_date"`
        InitialQuantity    int     `json:"initial_quantity"`
        ManufacturingDate  string  `json:"manufacturing_date"`
        ManufacturingHour  int     `json:"manufacturing_hour"`
        MinumumTemperature float64 `json:"minumum_temperature"`
        ProductID          int     `json:"product_id"`
        SectionID          int     `json:"section_id"`
}

type ProductBatchRepository interface {
        FindByID(id int) (ProductBatch, error)
        Save(prodBatch *ProductBatch) error
        ProductBatchNumberExists(batchNumber int) (bool, error)
}

type ProductBatchService interface {
        FindByID(id int) (ProductBatch, error)
        Save(prodBatch *ProductBatch) error
}

func (pb *ProductBatch) Ok() bool <span class="cov0" title="0">{
        if pb.BatchNumber &lt;= 0 ||
                pb.CurrentQuantity &lt; 0 ||
                pb.CurrentTemperature &lt; -273 ||
                pb.DueDate == "" ||
                pb.InitialQuantity &lt;= 0 ||
                pb.ManufacturingDate == "" ||
                pb.ManufacturingHour &lt; 0 ||
                pb.MinumumTemperature &lt; -273 ||
                pb.ProductID &lt;= 0 ||
                pb.SectionID &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package internal

import (
        "errors"
        "time"

        "github.com/meli-fresh-products-api-backend-t1/utils/validator"
)

// PurchaseOrder is a struct that represents a purchase order
type PurchaseOrder struct {
        ID              int
        OrderNumber     string
        OrderDate       time.Time
        TrackingCode    string
        BuyerID         int
        ProductRecordID int
}

var (
        // ErrPurchaseOrderRepositoryNotFound is returned when the purchase order is not found
        ErrPurchaseOrderNotFound = errors.New("purchase order not found")
        // ErrPurchaseOrderRepositoryConflict is returned when the purchase order already exists
        ErrPurchaseOrderConflict = errors.New("purchase order number already exists")
)

// Validate validates the purchase order fields
func (p *PurchaseOrder) Validate() (causes []Causes) <span class="cov0" title="0">{
        if !validator.String(p.OrderNumber, 1, 255) </span><span class="cov0" title="0">{
                causes = append(causes, Causes{
                        Field:   "order_number",
                        Message: "Order number is required",
                })
        }</span>

        <span class="cov0" title="0">if !validator.String(p.TrackingCode, 1, 255) </span><span class="cov0" title="0">{
                causes = append(causes, Causes{
                        Field:   "tracking_code",
                        Message: "Tracking code is required",
                })
        }</span>

        <span class="cov0" title="0">if validator.IntIsNegative(p.BuyerID) </span><span class="cov0" title="0">{
                causes = append(causes, Causes{
                        Field:   "buyer_id",
                        Message: "Buyer ID cannot be negative",
                })
        }</span>

        <span class="cov0" title="0">if validator.IntIsZero(p.BuyerID) </span><span class="cov0" title="0">{
                causes = append(causes, Causes{
                        Field:   "buyer_id",
                        Message: "Buyer ID is required",
                })
        }</span>

        <span class="cov0" title="0">if validator.IntIsNegative(p.ProductRecordID) </span><span class="cov0" title="0">{
                causes = append(causes, Causes{
                        Field:   "product_record_id",
                        Message: "Product record ID cannot be negative",
                })
        }</span>

        <span class="cov0" title="0">if validator.IntIsZero(p.ProductRecordID) </span><span class="cov0" title="0">{
                causes = append(causes, Causes{
                        Field:   "product_record_id",
                        Message: "Product record ID is required",
                })
        }</span>

        <span class="cov0" title="0">return causes</span>
}

// PurchaseOrderRepository is an interface that contains the methods that the purchase order repository should support
type PurchaseOrderRepository interface {
        // FindByID returns the purchase order with the given ID
        FindByID(id int) (PurchaseOrder, error)
        // Save saves the given purchase order
        Save(p *PurchaseOrder) error
}

// PurchaseOrderService is an interface that contains the methods that the purchase order service should support
type PurchaseOrderService interface {
        // FindByID returns the purchase order with the given ID
        FindByID(id int) (PurchaseOrder, error)
        // Save saves the given purchase order
        Save(p *PurchaseOrder) error
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "encoding/json"
        "log"
        "os"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

type BuyerMap struct {
        db     map[int]*internal.Buyer
        lastID int
}

func NewBuyerMap(dbPath string) *BuyerMap <span class="cov0" title="0">{
        var buyers []internal.Buyer

        db := make(map[int]*internal.Buyer)

        file, err := os.Open(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">err = json.NewDecoder(file).Decode(&amp;buyers)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">for i, b := range buyers </span><span class="cov0" title="0">{
                db[i] = &amp;b
        }</span>

        <span class="cov0" title="0">return &amp;BuyerMap{
                db:     db,
                lastID: len(buyers),
        }</span>
}

func (r *BuyerMap) GetAll() (db map[int]internal.Buyer) <span class="cov0" title="0">{
        db = make(map[int]internal.Buyer)

        for i, b := range r.db </span><span class="cov0" title="0">{
                db[i] = *b
        }</span>

        <span class="cov0" title="0">return</span>
}

func (r *BuyerMap) Add(buyer *internal.Buyer) <span class="cov0" title="0">{
        id := r.lastID
        buyer.ID = id
        r.db[id] = buyer
        r.lastID++
}</span>

func (r *BuyerMap) Update(id int, buyer internal.BuyerPatch) <span class="cov0" title="0">{
        buyerToPatch := r.db[id]
        buyer.Patch(buyerToPatch)
}</span>

func (r *BuyerMap) Delete(id int) <span class="cov0" title="0">{
        delete(r.db, id)
}</span>

func (r *BuyerMap) ReportPurchaseOrders() (purchaseOrders []internal.PurchaseOrdersByBuyer, err error) <span class="cov0" title="0">{
        return
}</span>

func (r *BuyerMap) ReportPurchaseOrdersByID(id int) (purchaseOrders []internal.PurchaseOrdersByBuyer, err error) <span class="cov0" title="0">{
        return
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "database/sql"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

func NewBuyerMysqlRepository(db *sql.DB) *BuyerMysqlRepository <span class="cov0" title="0">{
        return &amp;BuyerMysqlRepository{db}
}</span>

type BuyerMysqlRepository struct {
        db *sql.DB
}

func (r *BuyerMysqlRepository) GetAll() (db map[int]internal.Buyer) <span class="cov0" title="0">{
        db = make(map[int]internal.Buyer)
        query := `
                SELECT
                        id, card_number_id, first_name, last_name
                FROM
                        buyers;
        `

        /// executing the query
        rows, _ := r.db.Query(query)
        // iterating over the rows
        for rows.Next() </span><span class="cov0" title="0">{
                var buyer internal.Buyer

                _ = rows.Scan(&amp;buyer.ID, &amp;buyer.CardNumberID, &amp;buyer.FirstName, &amp;buyer.LastName) // TODO Actually check the error
                db[buyer.ID] = buyer
        }</span>

        <span class="cov0" title="0">return</span>
}

func (r *BuyerMysqlRepository) Add(buyer *internal.Buyer) <span class="cov0" title="0">{
        // Inserting the buyer
        query := `
                INSERT INTO buyers (card_number_id, first_name, last_name)
                VALUES (?, ?, ?)
        `

        result, _ := r.db.Exec(query, (*buyer).CardNumberID, (*buyer).FirstName, (*buyer).LastName)

        // Get the ID of the last inserted purchase order
        id, _ := result.LastInsertId()

        // Set the ID of the purchase order
        (*buyer).ID = int(id)
}</span>

func (r *BuyerMysqlRepository) Update(id int, buyer internal.BuyerPatch) <span class="cov0" title="0">{
        // Finding the buyer
        query :=
                `
                SELECT
                        id, card_number_id, first_name, last_name
                FROM
                        buyers
                WHERE
                        id = ?;
        `
        row := r.db.QueryRow(query, id)

        var b internal.Buyer
        _ = row.Scan(&amp;b.ID, &amp;b.CardNumberID, &amp;b.FirstName, &amp;b.LastName) // TODO Actually check the error

        buyer.Patch(&amp;b)

        query = `
                UPDATE buyers
                SET
                        card_number_id = ?, first_name = ?, last_name = ?
                WHERE
                        id = ?;
        `

        _, _ = r.db.Exec(query, buyer.CardNumberID, buyer.FirstName, buyer.LastName, id) // TODO: Actually check the error
}</span>

func (r *BuyerMysqlRepository) Delete(id int) <span class="cov0" title="0">{
        query := `
                DELETE FROM 
                        buyers
                WHERE
                        id = ?;
        `
        _, _ = r.db.Exec(query, id) // TODO Actually check the error
}</span>

func (r *BuyerMysqlRepository) ReportPurchaseOrders() (purchaseOrders []internal.PurchaseOrdersByBuyer, err error) <span class="cov0" title="0">{
        query := `
                SELECT
                        b.id, b.card_number_id, b.first_name, b.last_name, COUNT(po.id) as purchase_orders_count
                FROM
                        buyers as b
                LEFT JOIN
                        purchase_orders as po ON po.buyer_id = b.id
                GROUP BY
                        b.id;
        `
        // executing the query
        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // iterating over the rows
        for rows.Next() </span><span class="cov0" title="0">{
                var purchaseOrder internal.PurchaseOrdersByBuyer

                err = rows.Scan(&amp;purchaseOrder.BuyerID, &amp;purchaseOrder.CardNumberID, &amp;purchaseOrder.FirstName, &amp;purchaseOrder.LastName, &amp;purchaseOrder.PurchaseOrdersCount)
                if err != nil </span><span class="cov0" title="0">{
                        return purchaseOrders, err
                }</span>

                <span class="cov0" title="0">purchaseOrders = append(purchaseOrders, purchaseOrder)</span>
        }

        <span class="cov0" title="0">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return purchaseOrders, err
        }</span>

        <span class="cov0" title="0">return purchaseOrders, err</span>
}

func (r *BuyerMysqlRepository) ReportPurchaseOrdersByID(id int) (purchaseOrders []internal.PurchaseOrdersByBuyer, err error) <span class="cov0" title="0">{
        query := `
                SELECT
                        b.id, b.card_number_id, b.first_name, b.last_name, COUNT(po.id) as purchase_orders_count
                FROM
                        buyers as b
                LEFT JOIN
                        purchase_orders as po ON po.buyer_id = b.id
                GROUP BY
                        b.id
                HAVING
                        b.id = ?;
        `
        // executing the query
        rows, err := r.db.Query(query, id)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer rows.Close()

        // iterating over the rows
        for rows.Next() </span><span class="cov0" title="0">{
                var purchaseOrder internal.PurchaseOrdersByBuyer

                err = rows.Scan(&amp;purchaseOrder.BuyerID, &amp;purchaseOrder.CardNumberID, &amp;purchaseOrder.FirstName, &amp;purchaseOrder.LastName, &amp;purchaseOrder.PurchaseOrdersCount)
                if err != nil </span><span class="cov0" title="0">{
                        return purchaseOrders, err
                }</span>

                <span class="cov0" title="0">purchaseOrders = append(purchaseOrders, purchaseOrder)</span>
        }

        <span class="cov0" title="0">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return purchaseOrders, err
        }</span>

        <span class="cov0" title="0">return purchaseOrders, err</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "github.com/go-sql-driver/mysql"
        "github.com/meli-fresh-products-api-backend-t1/internal"
)

const (
        GetAllCarriesQuery = "SELECT * FROM carries"
)

var (
        ErrCidAlreadyExists = errors.New("carry with this cid already exists")
        ErrNoSuchLocalityID = errors.New("there's no such locality id")
)

type CarriesMysql struct {
        db *sql.DB
}

func NewCarriesMysql(db *sql.DB) *CarriesMysql <span class="cov0" title="0">{
        return &amp;CarriesMysql{db}
}</span>

func (r *CarriesMysql) FindAll() (carries []internal.Carries, e error) <span class="cov0" title="0">{
        rows, e := r.db.Query(GetAllCarriesQuery)
        if e != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var carry internal.Carries

                e = rows.Scan(
                        &amp;carry.ID,
                        &amp;carry.Cid,
                        &amp;carry.CompanyName,
                        &amp;carry.Address,
                        &amp;carry.PhoneNumber,
                        &amp;carry.LocalityID,
                )
                if e != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">carries = append(carries, carry)</span>
        }

        <span class="cov0" title="0">return</span>
}

func (r *CarriesMysql) Create(carry internal.Carries) (lastID int64, e error) <span class="cov0" title="0">{
        res, e := r.db.Exec(
                "INSERT INTO carries (`cid`, `company_name`, `address`, `phone_number`, `locality_id`) VALUES (?, ?, ?, ?, ?)",
                carry.Cid, carry.CompanyName, carry.Address, carry.PhoneNumber, carry.LocalityID,
        )
        if e != nil </span><span class="cov0" title="0">{
                mysqlErr, ok := e.(*mysql.MySQLError)
                if ok </span><span class="cov0" title="0">{
                        switch mysqlErr.Number </span>{
                        case 1062:<span class="cov0" title="0">
                                e = ErrCidAlreadyExists</span>
                        case 1452:<span class="cov0" title="0">
                                e = ErrNoSuchLocalityID</span>
                        }
                }

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">lastID, e = res.LastInsertId()

        return</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "encoding/json"
        "log"
        "os"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

type EmployeeRepositoryDefault struct {
        db map[int]*internal.Employee
}

func NewEmployeeRepository() *EmployeeRepositoryDefault <span class="cov0" title="0">{
        var employees []internal.Employee

        db := make(map[int]*internal.Employee)
        file, err := os.Open("db/employees.json") // open file employees

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // decode json and memory store in employees
        <span class="cov0" title="0">err = json.NewDecoder(file).Decode(&amp;employees)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // save employees in db
        <span class="cov0" title="0">for _, employee := range employees </span><span class="cov0" title="0">{
                if employee.ID &gt; 0 </span><span class="cov0" title="0">{
                        db[employee.ID] = &amp;employee
                }</span> else<span class="cov0" title="0"> {
                        log.Fatal(employee)
                }</span>
        }

        <span class="cov0" title="0">return &amp;EmployeeRepositoryDefault{ // return repository with db employees updated
                db: db,
        }</span>
}

func (r *EmployeeRepositoryDefault) GetAll() (db map[int]internal.Employee) <span class="cov0" title="0">{
        db = make(map[int]internal.Employee)

        for key, value := range r.db </span><span class="cov0" title="0">{ // get all employees in db
                db[key] = *value
        }</span>

        <span class="cov0" title="0">return</span>
}

func (r *EmployeeRepositoryDefault) Save(emp *internal.Employee) int <span class="cov0" title="0">{
        if emp.ID == 0 </span><span class="cov0" title="0">{
                emp.ID = len(r.db) + 1 //increment id
        }</span>

        <span class="cov0" title="0">r.db[emp.ID] = emp // add new employee in db

        return emp.ID</span>
}

func (r *EmployeeRepositoryDefault) Update(id int, employee internal.Employee) <span class="cov0" title="0">{
        if emp, ok := r.db[id]; ok </span><span class="cov0" title="0">{
                emp.CardNumberID = employee.CardNumberID
                emp.FirstName = employee.FirstName
                emp.LastName = employee.LastName
                emp.WarehouseID = employee.WarehouseID
        }</span>
}

func (r *EmployeeRepositoryDefault) Delete(id int) <span class="cov0" title="0">{
        delete(r.db, id)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "database/sql"
        "errors"
        "fmt"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

type EmployeeMysql struct {
        db *sql.DB
}

func NewEmployeeMysql(db *sql.DB) *EmployeeMysql <span class="cov0" title="0">{
        return &amp;EmployeeMysql{db}
}</span>

const (
        InboundOrdersPerEmployeeQuery = `
        SELECT COUNT(i.employee_id) AS inbound_orders_count, e.id, e.card_number_id, e.first_name, e.last_name, i.warehouse_id
        FROM inbound_orders i
        INNER JOIN employees e ON i.employee_id = e.id
        GROUP BY i.employee_id, i.id;`

        InboundOrdersPerEmployeeByIDQuery = `
        SELECT COUNT(i.employee_id) AS inbound_orders_count, i.id, e.card_number_id, e.first_name, e.last_name, i.warehouse_id
        FROM inbound_orders i
        INNER JOIN employees e ON i.employee_id = e.id
        WHERE i.employee_id = ?
        GROUP BY i.employee_id, i.id;`
)

func (r *EmployeeMysql) GetAll() (db []internal.Employee, err error) <span class="cov0" title="0">{
        rows, err := r.db.Query("SELECT id, card_number_id, first_name, last_name, warehouse_id FROM employees")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var emp internal.Employee
                if err := rows.Scan(&amp;emp.ID, &amp;emp.CardNumberID, &amp;emp.FirstName, &amp;emp.LastName, &amp;emp.WarehouseID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">db = append(db, emp)</span>
        }

        <span class="cov0" title="0">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrEmployeeNotFound
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">return</span>
}

func (r *EmployeeMysql) GetByID(id int) (emp internal.Employee, err error) <span class="cov0" title="0">{
        row := r.db.QueryRow("SELECT id, card_number_id, first_name, last_name, warehouse_id FROM employees WHERE id = ?", id)

        if err := row.Scan(&amp;emp.ID, &amp;emp.CardNumberID, &amp;emp.FirstName, &amp;emp.LastName, &amp;emp.WarehouseID); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return emp, fmt.Errorf("employee not found")
                }</span>

                <span class="cov0" title="0">return emp, err</span>
        }

        <span class="cov0" title="0">return emp, nil</span>
}

func (r *EmployeeMysql) Save(emp *internal.Employee) (int, error) <span class="cov0" title="0">{
        var err error

        var existingEmployee internal.Employee
        err = r.db.QueryRow(
                "SELECT id FROM employees WHERE card_number_id = ?",
                emp.CardNumberID).Scan(&amp;existingEmployee.ID)

        if err == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("employee with card_number_id %s already exists", emp.CardNumberID)
        }</span> else<span class="cov0" title="0"> if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">_, err = r.db.Exec(
                "INSERT INTO employees (card_number_id, first_name, last_name, warehouse_id) VALUES (?, ?, ?, ?)",
                emp.CardNumberID, emp.FirstName, emp.LastName, emp.WarehouseID)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = r.db.QueryRow("SELECT LAST_INSERT_ID()").Scan(&amp;emp.ID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return emp.ID, nil</span>
}

func (r *EmployeeMysql) Update(id int, employee internal.Employee) error <span class="cov0" title="0">{
        _, err := r.db.Exec(
                "UPDATE employees SET card_number_id = ?, first_name = ?, last_name = ?, warehouse_id = ? WHERE id = ?",
                employee.CardNumberID, employee.FirstName, employee.LastName, employee.WarehouseID, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *EmployeeMysql) Delete(id int) error <span class="cov0" title="0">{
        _, err := r.db.Exec("DELETE FROM employees WHERE id = ?", id)
        return err
}</span>

func (r *EmployeeMysql) CountInboundOrdersPerEmployee() (io []internal.InboundOrdersPerEmployee, err error) <span class="cov0" title="0">{
        row, err := r.db.Query(InboundOrdersPerEmployeeQuery)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for row.Next() </span><span class="cov0" title="0">{
                var countInboundPerEmployee internal.InboundOrdersPerEmployee

                err = row.Scan(&amp;countInboundPerEmployee.CountInOrders, &amp;countInboundPerEmployee.ID, &amp;countInboundPerEmployee.CardNumberID, &amp;countInboundPerEmployee.FirstName, &amp;countInboundPerEmployee.LastName, &amp;countInboundPerEmployee.WarehouseID)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">io = append(io, countInboundPerEmployee)</span>
        }

        <span class="cov0" title="0">return</span>
}

func (r *EmployeeMysql) ReportInboundOrdersByID(employeeID int) (io internal.InboundOrdersPerEmployee, err error) <span class="cov0" title="0">{
        row := r.db.QueryRow(
                InboundOrdersPerEmployeeByIDQuery,
                employeeID,
        )

        err = row.Scan(&amp;io.CountInOrders, &amp;io.ID, &amp;io.CardNumberID, &amp;io.FirstName, &amp;io.LastName, &amp;io.WarehouseID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrEmployeeNotFound
                }</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "database/sql"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

const (
        AllInboundsQuery = "SELECT `id`, `order_date`, `order_number`, `employee_id`, `product_batch_id`, `warehouse_id` FROM `inbound_orders`;"
)

// InboundOrdersMysql create a new instance of the inbound orders repository
type InboundOrdersMysql struct {
        db *sql.DB
}

func NewInboundOrderMysql(db *sql.DB) *InboundOrdersMysql <span class="cov0" title="0">{
        return &amp;InboundOrdersMysql{db}
}</span>

func (rp *InboundOrdersMysql) Create(io internal.InboundOrders) (id int64, err error) <span class="cov0" title="0">{
        var exists bool

        err = rp.db.QueryRow("SELECT 1 FROM `inbound_orders` WHERE `order_number` = ?", io.OrderNumber).Scan(&amp;exists) //check 1 line
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return 0, internal.ErrOrderNumberAlreadyExists
        }</span>

        <span class="cov0" title="0">var empExists bool

        err = rp.db.QueryRow("SELECT 1 FROM `employees` WHERE `id` = ?", io.EmployeeID).Scan(&amp;empExists) //check 1 line
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">if !empExists </span><span class="cov0" title="0">{
                return 0, internal.ErrEmployeeNotFound
        }</span>

        <span class="cov0" title="0">res, err := rp.db.Exec(
                "INSERT INTO `inbound_orders` (`order_date`, `order_number`, `employee_id`, `product_batch_id`, `warehouse_id`) VALUES (?, ?, ?, ?, ?)",
                io.OrderDate, io.OrderNumber, io.EmployeeID, io.ProductBatchID, io.WarehouseID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">id, err = res.LastInsertId()

        return id, err</span>
}

func (rp *InboundOrdersMysql) FindAll() (inbounds []internal.InboundOrders, err error) <span class="cov0" title="0">{
        row, err := rp.db.Query(AllInboundsQuery)

        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for row.Next() </span><span class="cov0" title="0">{
                var inboundOrder internal.InboundOrders
                err = row.Scan(&amp;inboundOrder.ID, &amp;inboundOrder.OrderDate, &amp;inboundOrder.OrderNumber, &amp;inboundOrder.EmployeeID, &amp;inboundOrder.ProductBatchID, &amp;inboundOrder.WarehouseID)

                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">inbounds = append(inbounds, inboundOrder)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "github.com/go-sql-driver/mysql"
        "github.com/meli-fresh-products-api-backend-t1/internal"
)

const (
        AmountOfCarriesForEveryLocalityQuery = `
        SELECT COUNT(c.locality_id) carries_count, c.locality_id, l.name locality_name
        FROM carries c
        INNER JOIN localities l
        ON l.id = c.locality_id
        GROUP BY c.locality_id;
        `
)

// NewLocalityMysql creates a new instance of the seller repository
func NewLocalityMysql(db *sql.DB) *LocalityMysql <span class="cov8" title="1">{
        return &amp;LocalityMysql{db}
}</span>

// LocalityMysql is the mysql implementation of the seller repository
type LocalityMysql struct {
        // db is the database connection to mysql
        db *sql.DB
}

func (r *LocalityMysql) ReportCarries(localityID int) (amountOfCarries int, e error) <span class="cov0" title="0">{
        row := r.db.QueryRow(
                "SELECT COUNT(c.locality_id) carries_registered FROM carries c WHERE locality_id = ?",
                localityID,
        )

        e = row.Scan(&amp;amountOfCarries)

        if amountOfCarries == 0 || e != nil </span><span class="cov0" title="0">{
                e = sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return</span>
}

func (r *LocalityMysql) GetAmountOfCarriesForEveryLocality() (c []internal.CarriesCountPerLocality, e error) <span class="cov0" title="0">{
        rows, e := r.db.Query(AmountOfCarriesForEveryLocalityQuery)
        if e != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var carryCountPerLocality internal.CarriesCountPerLocality

                e = rows.Scan(
                        &amp;carryCountPerLocality.CarriesCount,
                        &amp;carryCountPerLocality.LocalityID,
                        &amp;carryCountPerLocality.LocalityName,
                )
                if e != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">c = append(c, carryCountPerLocality)</span>
        }

        <span class="cov0" title="0">return</span>
}

// Save saves a locality into the database
func (r *LocalityMysql) Save(locality *internal.Locality) (err error) <span class="cov8" title="1">{
        // execute the query
        _, err = r.db.Exec(
                "INSERT INTO `localities` (`id`, `name`, `province_name`, `country_name`) VALUES (?, ?, ?, ?)",
                (*locality).ID, (*locality).LocalityName, (*locality).ProvinceName, (*locality).CountryName,
        )
        if err != nil </span><span class="cov8" title="1">{
                var mysqlErr *mysql.MySQLError
                if errors.As(err, &amp;mysqlErr) </span><span class="cov8" title="1">{
                        switch mysqlErr.Number </span>{
                        case 1062:<span class="cov8" title="1">
                                err = internal.ErrLocalityConflict</span>
                        }
                }
        }

        <span class="cov8" title="1">return</span>
}

func (r *LocalityMysql) ReportSellers() (localities []internal.Locality, err error) <span class="cov8" title="1">{
        rows, err := r.db.Query("SELECT l.id, l.name, l.province_name, l.country_name, COUNT(s.id) FROM localities AS l LEFT JOIN sellers AS s ON l.id = s.locality_id GROUP BY l.id")
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        err = internal.ErrLocalityNotFound
                }</span>

                <span class="cov8" title="1">return localities, err</span>
        }

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var locality internal.Locality

                err = rows.Scan(&amp;locality.ID, &amp;locality.LocalityName, &amp;locality.ProvinceName, &amp;locality.CountryName, &amp;locality.Sellers)
                if err != nil </span><span class="cov0" title="0">{
                        return localities, err
                }</span>

                <span class="cov8" title="1">localities = append(localities, locality)</span>
        }

        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrLocalityNotFound
                }</span>

                <span class="cov0" title="0">return localities, err</span>
        }

        <span class="cov8" title="1">return localities, err</span>
}

// ReportSellersByID returns a seller from the database by its id
func (r *LocalityMysql) ReportSellersByID(id int) (localities []internal.Locality, err error) <span class="cov8" title="1">{
        // execute the query
        row := r.db.QueryRow("SELECT l.id, l.name, l.province_name, l.country_name, COUNT(s.id) FROM localities AS l LEFT JOIN sellers AS s ON l.id = s.locality_id WHERE l.id = ? GROUP BY l.id", id)

        var locality internal.Locality
        // scan the row into the seller
        err = row.Scan(&amp;locality.ID, &amp;locality.LocalityName, &amp;locality.ProvinceName, &amp;locality.CountryName, &amp;locality.Sellers)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        err = internal.ErrLocalityNotFound
                }</span>
        }

        <span class="cov8" title="1">localities = append(localities, locality)

        return</span>
}

func (r *LocalityMysql) FindByID(id int) (locality internal.Locality, err error) <span class="cov8" title="1">{
        // execute the query
        row := r.db.QueryRow("SELECT `id`, `name`, `province_name`, `country_name` FROM `localities` WHERE `id` = ?", id)

        // scan the row into the seller
        err = row.Scan(&amp;locality.ID, &amp;locality.LocalityName, &amp;locality.ProvinceName, &amp;locality.CountryName)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        err = internal.ErrLocalityNotFound
                }</span>
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

type ProductSQL struct {
        db *sql.DB
}

func NewProductSQL(db *sql.DB) *ProductSQL <span class="cov0" title="0">{
        return &amp;ProductSQL{db}
}</span>

const (
        findAllString  = "SELECT id, description, expiration_rate, freezing_rate, height, length, net_weight, product_code, recommended_freezing_temperature, width, product_type_id, seller_id FROM products"
        findByIDString = "SELECT id, description, expiration_rate, freezing_rate, height, length, net_weight, product_code, recommended_freezing_temperature, width, product_type_id, seller_id FROM products WHERE id = ?"
)

func (psql *ProductSQL) FindAll() (products []internal.Product, err error) <span class="cov0" title="0">{
        rows, err := psql.db.Query(findAllString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var product internal.Product

                err := rows.Scan(&amp;product.ID, &amp;product.Description, &amp;product.ExpirationRate, &amp;product.FreezingRate,
                        &amp;product.Height, &amp;product.Length, &amp;product.NetWeight, &amp;product.ProductCode, &amp;product.RecommendedFreezingTemperature,
                        &amp;product.Width, &amp;product.ProductTypeID, &amp;product.SellerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">products = append(products, product)</span>
        }

        <span class="cov0" title="0">return</span>
}
func (psql *ProductSQL) FindByID(id int) (internal.Product, error) <span class="cov0" title="0">{
        var product internal.Product

        row := psql.db.QueryRow(findByIDString, id)

        err := row.Scan(&amp;product.ID, &amp;product.Description, &amp;product.ExpirationRate, &amp;product.FreezingRate,
                &amp;product.Height, &amp;product.Length, &amp;product.NetWeight, &amp;product.ProductCode, &amp;product.RecommendedFreezingTemperature,
                &amp;product.Width, &amp;product.ProductTypeID, &amp;product.SellerID)
        if err != nil </span><span class="cov0" title="0">{
                return product, err
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}

func (psql *ProductSQL) Save(product internal.Product) (internal.Product, error) <span class="cov0" title="0">{
        _, err := psql.db.Exec(
                "INSERT INTO products (id, description, expiration_rate, freezing_rate, height, length, net_weight, product_code, recommended_freezing_temperature, width, product_type_id, seller_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                product.ID,
                product.Description,
                product.ExpirationRate,
                product.FreezingRate,
                product.Height,
                product.Length,
                product.NetWeight,
                product.ProductCode,
                product.RecommendedFreezingTemperature,
                product.Width,
                product.ProductTypeID,
                product.SellerID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return product, err
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}

func (psql *ProductSQL) Update(product internal.Product) (internal.Product, error) <span class="cov0" title="0">{
        result, err := psql.db.Exec(
                `UPDATE product 
                 SET description = ?, expiration_rate = ?, freezing_rate = ?, 
                     height = ?, length = ?, net_weight = ?, 
                     product_code = ?, recommended_freezing_temperature = ?, 
                     width = ?, product_type_id = ?, seller_id = ?
                 WHERE id = ?`,
                product.Description,
                product.ExpirationRate,
                product.FreezingRate,
                product.Height,
                product.Length,
                product.NetWeight,
                product.ProductCode,
                product.RecommendedFreezingTemperature,
                product.Width,
                product.ProductTypeID,
                product.SellerID,
                product.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return internal.Product{}, err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return internal.Product{}, err
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return internal.Product{}, errors.New("product not found")
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}

func (psql *ProductSQL) Delete(id int) error <span class="cov0" title="0">{
        result, err := psql.db.Exec("DELETE FROM product WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("product not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (psql *ProductSQL) FindAllRecord() ([]internal.ProductRecordsJSONCount, error) <span class="cov0" title="0">{
        var products []internal.ProductRecordsJSONCount

        rows, err := psql.db.Query("SELECT pr.product_id, p.description, COUNT(*) AS records_count FROM product_records pr JOIN products p ON pr.product_id = p.id GROUP BY pr.product_id, p.description;")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var product internal.ProductRecordsJSONCount

                err := rows.Scan(&amp;product.ProductID, &amp;product.Description, &amp;product.RecordsCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">products = append(products, product)</span>
        }

        <span class="cov0" title="0">return products, nil</span>
}

func (psql *ProductSQL) FindByIDRecord(id int) (internal.ProductRecordsJSONCount, error) <span class="cov0" title="0">{
        var product internal.ProductRecordsJSONCount

        row := psql.db.QueryRow("SELECT pr.product_id, p.description, COUNT(*) AS records_count FROM product_records pr JOIN products p ON pr.product_id = p.id WHERE p.id = ? GROUP BY pr.product_id, p.description;", id)

        err := row.Scan(&amp;product.ProductID, &amp;product.Description, &amp;product.RecordsCount)
        if err != nil </span><span class="cov0" title="0">{
                return product, err
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "github.com/go-sql-driver/mysql"
        "github.com/meli-fresh-products-api-backend-t1/internal"
)

func NewProductBatchMysql(db *sql.DB) *ProductBatchMysql <span class="cov0" title="0">{
        return &amp;ProductBatchMysql{db}
}</span>

type ProductBatchMysql struct {
        db *sql.DB
}

func (r *ProductBatchMysql) FindByID(id int) (internal.ProductBatch, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                pb.id,
                pb.batch_number,
                pb.current_quantity,
                pb.current_temperature,
                pb.due_date,
                pb.initial_quantity,
                pb.manufacturing_date,
                pb.manufacturing_hour,
                pb.minumum_temperature,           
                pb.product_id,           
                pb.section_id           
        FROM 
                product_batches pb
        WHERE 
                id = ?`

        var pb internal.ProductBatch

        err := r.db.QueryRow(query, id).Scan(
                &amp;pb.ID,
                &amp;pb.BatchNumber,
                &amp;pb.CurrentQuantity,
                &amp;pb.CurrentTemperature,
                &amp;pb.DueDate,
                &amp;pb.InitialQuantity,
                &amp;pb.ManufacturingDate,
                &amp;pb.ManufacturingHour,
                &amp;pb.MinumumTemperature,
                &amp;pb.ProductID,
                &amp;pb.SectionID,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return pb, internal.ErrProductBatchNotFound
                }</span>

                <span class="cov0" title="0">return pb, err</span>
        }

        <span class="cov0" title="0">return pb, nil</span>
}

func (r *ProductBatchMysql) Save(prodBatch *internal.ProductBatch) error <span class="cov0" title="0">{
        result, err := r.db.Exec(
                "INSERT INTO product_batches (batch_number, current_quantity, current_temperature, due_date, initial_quantity, manufacturing_date, manufacturing_hour, minumum_temperature, product_id, section_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                prodBatch.BatchNumber,
                prodBatch.CurrentQuantity,
                prodBatch.CurrentTemperature,
                prodBatch.DueDate,
                prodBatch.InitialQuantity,
                prodBatch.ManufacturingDate,
                prodBatch.ManufacturingHour,
                prodBatch.MinumumTemperature,
                prodBatch.ProductID,
                prodBatch.SectionID,
        )

        if err != nil </span><span class="cov0" title="0">{
                var mysqlErr *mysql.MySQLError
                if errors.As(err, &amp;mysqlErr) </span><span class="cov0" title="0">{
                        switch mysqlErr.Number </span>{
                        case 1062:<span class="cov0" title="0">
                                return internal.ErrProductBatchAlreadyExists</span>
                        }
                }

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">prodBatch.ID = int(id)

        return nil</span>
}

func (r *ProductBatchMysql) ProductBatchNumberExists(batchNumber int) (bool, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM product_batches WHERE batch_number = ?"

        var count int

        err := r.db.QueryRow(query, batchNumber).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *ProductBatchMysql) ReportProducts() (prodBatches []internal.ProductBatch, err error) <span class="cov0" title="0">{
        query := `
        SELECT 
                pb.batch_number,
                pb.current_quantity,
                pb.current_temperature,
                pb.due_date,
                pb.initial_quantity,
                pb.manufacturing_date,
                pb.manufacturing_hour,
                pb.minumum_temperature,
                p.product_code,        
                s.section_number       
        FROM 
                product_batches pb
        JOIN 
                products p ON pb.product_id = p.id
        JOIN 
                sections s ON pb.section_id = s.id
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, internal.ErrProductBatchNotFound
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var pb internal.ProductBatch
                if err := rows.Scan(
                        &amp;pb.BatchNumber,
                        &amp;pb.CurrentQuantity,
                        &amp;pb.CurrentTemperature,
                        &amp;pb.DueDate,
                        &amp;pb.InitialQuantity,
                        &amp;pb.ManufacturingDate,
                        &amp;pb.ManufacturingHour,
                        &amp;pb.MinumumTemperature,
                        &amp;pb.ProductID,
                        &amp;pb.SectionID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, internal.ErrProductBatchNotFound
                }</span>

                <span class="cov0" title="0">prodBatches = append(prodBatches, pb)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, internal.ErrProductBatchNotFound
        }</span>

        <span class="cov0" title="0">return prodBatches, nil</span>
}

func (r *ProductBatchMysql) ReportProductsByID(id int) (prodBatches []internal.ProductBatch, err error) <span class="cov0" title="0">{
        query := `
        SELECT 
                pb.batch_number,
                pb.current_quantity,
                pb.current_temperature,
                pb.due_date,
                pb.initial_quantity,
                pb.manufacturing_date,
                pb.manufacturing_hour,
                pb.minumum_temperature,
                p.product_code,         
                s.section_number      
        FROM 
                product_batches pb
        JOIN 
                products p ON pb.product_id = p.id
        JOIN 
                sections s ON pb.section_id = s.id
        WHERE 
                pb.id = ?
        `

        row := r.db.QueryRow(query, id)

        var pb internal.ProductBatch
        if err := row.Scan(
                &amp;pb.BatchNumber,
                &amp;pb.CurrentQuantity,
                &amp;pb.CurrentTemperature,
                &amp;pb.DueDate,
                &amp;pb.InitialQuantity,
                &amp;pb.ManufacturingDate,
                &amp;pb.ManufacturingHour,
                &amp;pb.MinumumTemperature,
                &amp;pb.ProductID,
                &amp;pb.SectionID,
        ); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, internal.ErrProductBatchNotFound
                }</span>

                <span class="cov0" title="0">return nil, internal.ErrProductBatchNotFound</span>
        }

        <span class="cov0" title="0">prodBatches = append(prodBatches, pb)

        return prodBatches, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package repository

import (
        "database/sql"

        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/service"
)

type ProductRecordsSQL struct {
        db *sql.DB
}

func NewProductRecordsSQL(db *sql.DB) *ProductRecordsSQL <span class="cov0" title="0">{
        return &amp;ProductRecordsSQL{db}
}</span>

func (psql *ProductRecordsSQL) FindAll() (productRecords []internal.ProductRecords, err error) <span class="cov0" title="0">{
        rows, err := psql.db.Query("SELECT `id`, `last_update_date`, `purchase_price`, `sale_price`, `product_id` FROM `product_records`")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var productRecord internal.ProductRecords

                err := rows.Scan(&amp;productRecord.ID, &amp;productRecord.LastUpdateDate, &amp;productRecord.PurchasePrice, &amp;productRecord.SalePrice, &amp;productRecord.ProductID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">productRecords = append(productRecords, productRecord)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return productRecords, nil</span>
}

func (psql *ProductRecordsSQL) FindByID(id int) (internal.ProductRecords, error) <span class="cov0" title="0">{
        var productRecord internal.ProductRecords

        row := psql.db.QueryRow("SELECT `id`, `last_update_date`, `purchase_price`, `sale_price`, `product_id` FROM `product_records` WHERE `id` = ?", id)
        err := row.Scan(&amp;productRecord.ID, &amp;productRecord.LastUpdateDate, &amp;productRecord.PurchasePrice, &amp;productRecord.SalePrice, &amp;productRecord.ProductID)

        if err != nil </span><span class="cov0" title="0">{
                return productRecord, service.ErrProductRecordsNotFound
        }</span>

        <span class="cov0" title="0">return productRecord, nil</span>
}

func (psql *ProductRecordsSQL) Save(productRec internal.ProductRecords) (internal.ProductRecords, error) <span class="cov0" title="0">{
        _, err := psql.db.Exec(
                "INSERT INTO `product_records` (`last_update_date`, `purchase_price`, `sale_price`, `product_id`) VALUES (?, ?, ?, ?)",
                productRec.LastUpdateDate, productRec.PurchasePrice, productRec.SalePrice, productRec.ProductID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return productRec, err
        }</span>

        <span class="cov0" title="0">return productRec, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "errors"

        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/loader"
)

func NewProductType() *ProductTypeDB <span class="cov0" title="0">{
        bdProdTypes := make(map[int]*internal.ProductType)

        prodTypeDBList, err := loader.ReadAllProductsTypeToFile()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ProductTypeDB{
                        DB: bdProdTypes,
                }
        }</span>

        <span class="cov0" title="0">for _, value := range prodTypeDBList </span><span class="cov0" title="0">{
                section := internal.ProductType{
                        ID: value.ID,
                }

                bdProdTypes[value.ID] = &amp;section
        }</span>

        <span class="cov0" title="0">return &amp;ProductTypeDB{
                DB: bdProdTypes,
        }</span>
}

type ProductTypeDB struct {
        DB map[int]*internal.ProductType
}

func (r *ProductTypeDB) FindByID(id int) (internal.ProductType, error) <span class="cov0" title="0">{
        productType, exists := r.DB[id]
        if !exists </span><span class="cov0" title="0">{
                return internal.ProductType{}, errors.New("product_type not found")
        }</span>

        <span class="cov0" title="0">return *productType, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

func NewProductTypeMysql(db *sql.DB) *ProductTypeMysql <span class="cov0" title="0">{
        return &amp;ProductTypeMysql{db}
}</span>

type ProductTypeMysql struct {
        db *sql.DB
}

func (r *ProductTypeMysql) FindByID(id int) (internal.ProductType, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                id,
                description          
        FROM 
                product_type
        WHERE 
                id = ?`

        var pt internal.ProductType

        err := r.db.QueryRow(query, id).Scan(
                &amp;pt.ID,
                &amp;pt.Description,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return pt, internal.ErrProductTypeNotFound
                }</span>

                <span class="cov0" title="0">return pt, err</span>
        }

        <span class="cov0" title="0">return pt, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "database/sql"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

func NewPurchaseOrderMysqlRepository(db *sql.DB) *PurchaseOrderRepository <span class="cov0" title="0">{
        return &amp;PurchaseOrderRepository{db}
}</span>

type PurchaseOrderRepository struct {
        db *sql.DB
}

func (r *PurchaseOrderRepository) FindByID(id int) (purchaseOrder internal.PurchaseOrder, err error) <span class="cov0" title="0">{
        query := `
                SELECT po.id, po.order_number, po.order_date, po.tracking_code, po.buyer_id, po.product_record_id
                FROM purchase_orders as po
                WHERE po.id = ?
        `
        row := r.db.QueryRow(query, id)

        if err = row.Err(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // scanning the row
        <span class="cov0" title="0">err = row.Scan(
                &amp;purchaseOrder.ID,
                &amp;purchaseOrder.OrderNumber,
                &amp;purchaseOrder.OrderDate,
                &amp;purchaseOrder.TrackingCode,
                &amp;purchaseOrder.BuyerID,
                &amp;purchaseOrder.ProductRecordID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        err = internal.ErrPurchaseOrderNotFound
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">return</span>
}

// Save creates a new purchase order in the database
func (r *PurchaseOrderRepository) Save(purchaseOrder *internal.PurchaseOrder) error <span class="cov0" title="0">{
        // Checking if the purchase order already exists
        row := r.db.QueryRow("SELECT COUNT(*) FROM purchase_orders WHERE order_number = ?", purchaseOrder.OrderNumber)

        var count int

        err := row.Scan(&amp;count)
        if count &gt; 0 || err != nil </span><span class="cov0" title="0">{
                return internal.ErrPurchaseOrderConflict
        }</span>

        // Inserting the purchase order
        <span class="cov0" title="0">query := `
                INSERT INTO purchase_orders (order_number, order_date, tracking_code, buyer_id, product_record_id)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query, (*purchaseOrder).OrderNumber, (*purchaseOrder).OrderDate, (*purchaseOrder).TrackingCode, (*purchaseOrder).BuyerID, (*purchaseOrder).ProductRecordID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the ID of the last inserted purchase order
        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the ID of the purchase order
        <span class="cov0" title="0">(*purchaseOrder).ID = int(id)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "errors"

        "github.com/meli-fresh-products-api-backend-t1/internal"
        "github.com/meli-fresh-products-api-backend-t1/internal/loader"
)

func NewRepositorySection() *SectionDB <span class="cov0" title="0">{
        bdSections := make(map[int]*internal.Section)

        sectionList, err := loader.ReadAllSectionsToFile()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;SectionDB{
                        DB: bdSections,
                }
        }</span>

        <span class="cov0" title="0">for _, value := range sectionList </span><span class="cov0" title="0">{
                section := internal.Section{
                        ID:                 value.ID,
                        SectionNumber:      value.SectionNumber,
                        CurrentTemperature: value.CurrentTemperature,
                        MinimumTemperature: value.MinimumTemperature,
                        CurrentCapacity:    value.CurrentCapacity,
                        MinimumCapacity:    value.MinimumCapacity,
                        MaximumCapacity:    value.MaximumCapacity,
                        WarehouseID:        value.WarehouseID,
                        ProductTypeID:      value.ProductTypeID,
                }

                bdSections[value.ID] = &amp;section
        }</span>

        <span class="cov0" title="0">return &amp;SectionDB{
                DB:     bdSections,
                lastID: len(bdSections),
        }</span>
}

type SectionDB struct {
        DB     map[int]*internal.Section
        lastID int
}

func (r *SectionDB) FindAll() ([]internal.Section, error) <span class="cov0" title="0">{
        sections := make([]internal.Section, 0, len(r.DB))

        if len(r.DB) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no sections available")
        }</span>

        <span class="cov0" title="0">for _, section := range r.DB </span><span class="cov0" title="0">{
                sections = append(sections, *section)
        }</span>

        <span class="cov0" title="0">return sections, nil</span>
}

func (r *SectionDB) FindByID(id int) (internal.Section, error) <span class="cov0" title="0">{
        section, exists := r.DB[id]
        if !exists </span><span class="cov0" title="0">{
                return internal.Section{}, errors.New("section not found")
        }</span>

        <span class="cov0" title="0">return *section, nil</span>
}

func (r *SectionDB) ReportProducts() (int, error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (r *SectionDB) ReportProductsByID(id int) (int, error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (r *SectionDB) SectionNumberExists(section internal.Section) error <span class="cov0" title="0">{
        for _, value := range r.DB </span><span class="cov0" title="0">{
                if value.ID != section.ID &amp;&amp; value.SectionNumber == section.SectionNumber </span><span class="cov0" title="0">{
                        return errors.New("section with this section number already exists")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *SectionDB) Save(section *internal.Section) error <span class="cov0" title="0">{
        r.lastID++
        section.ID = r.lastID

        if _, exists := r.DB[section.ID]; exists </span><span class="cov0" title="0">{
                return errors.New("section already exists")
        }</span>

        <span class="cov0" title="0">r.DB[section.ID] = section

        return nil</span>
}

func (r *SectionDB) Update(section *internal.Section) error <span class="cov0" title="0">{
        if _, exists := r.DB[section.ID]; !exists </span><span class="cov0" title="0">{
                return errors.New("section not found")
        }</span>

        <span class="cov0" title="0">r.DB[section.ID] = section

        return nil</span>
}

func (r *SectionDB) Delete(id int) error <span class="cov0" title="0">{
        if _, exists := r.DB[id]; !exists </span><span class="cov0" title="0">{
                return errors.New("section not found")
        }</span>

        <span class="cov0" title="0">delete(r.DB, id)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

func NewSectionMysql(db *sql.DB) *SectionMysql <span class="cov0" title="0">{
        return &amp;SectionMysql{db}
}</span>

type SectionMysql struct {
        db *sql.DB
}

func (r *SectionMysql) FindAll() ([]internal.Section, error) <span class="cov0" title="0">{
        rows, err := r.db.Query("SELECT `id`, `section_number`, `current_temperature`, `minimum_temperature`, `current_capacity`, `minimum_capacity`, `maximum_capacity`, `warehouse_id`, `product_type_id` FROM sections")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrSectionNotFound
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        var sections []internal.Section

        for rows.Next() </span><span class="cov0" title="0">{
                var s internal.Section

                err := rows.Scan(&amp;s.ID, &amp;s.SectionNumber, &amp;s.CurrentTemperature, &amp;s.MinimumTemperature, &amp;s.CurrentCapacity, &amp;s.MinimumCapacity, &amp;s.MaximumCapacity, &amp;s.WarehouseID, &amp;s.ProductTypeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">sections = append(sections, s)</span>
        }

        <span class="cov0" title="0">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrSectionNotFound
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return sections, nil</span>
}

func (r *SectionMysql) FindByID(id int) (internal.Section, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                id, 
                section_number, 
                current_temperature, 
                minimum_temperature, 
                current_capacity, 
                minimum_capacity, 
                maximum_capacity, 
                warehouse_id, 
                product_type_id 
        FROM 
                sections 
        WHERE 
                id = ?`

        var s internal.Section

        err := r.db.QueryRow(query, id).Scan(&amp;s.ID, &amp;s.SectionNumber, &amp;s.CurrentTemperature, &amp;s.MinimumTemperature, &amp;s.CurrentCapacity, &amp;s.MinimumCapacity, &amp;s.MaximumCapacity, &amp;s.WarehouseID, &amp;s.ProductTypeID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return s, internal.ErrSectionNotFound
                }</span>

                <span class="cov0" title="0">return s, err</span>
        }

        <span class="cov0" title="0">return s, nil</span>
}

func (r *SectionMysql) ReportProducts() ([]internal.ReportProduct, error) <span class="cov0" title="0">{
        query := `
        SELECT 
            s.id AS section_id,
            s.section_number,
            COALESCE(SUM(pb.current_quantity), 0) AS products_count
        FROM 
            sections s
        LEFT JOIN 
            product_batches pb ON s.id = pb.section_id
        GROUP BY 
            s.id, s.section_number;`

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var report []internal.ReportProduct

        for rows.Next() </span><span class="cov0" title="0">{
                var rp internal.ReportProduct

                if err := rows.Scan(&amp;rp.SectionID, &amp;rp.SectionNumber, &amp;rp.ProductsCount); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">report = append(report, rp)</span>
        }

        <span class="cov0" title="0">return report, nil</span>
}

func (r *SectionMysql) ReportProductsByID(sectionID int) (internal.ReportProduct, error) <span class="cov0" title="0">{
        query := `
                        SELECT 
                                s.id AS section_id,
                                s.section_number,
                                COALESCE(SUM(pb.current_quantity), 0) AS products_count
                        FROM 
                                sections s
                        LEFT JOIN 
                                product_batches pb ON s.id = pb.section_id
                        WHERE 
                                s.id = ?
                        GROUP BY 
                                s.id, s.section_number;`

        var rp internal.ReportProduct

        err := r.db.QueryRow(query, sectionID).Scan(&amp;rp.SectionID, &amp;rp.SectionNumber, &amp;rp.ProductsCount)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        rp.ProductsCount = 0
                        return rp, nil
                }</span>

                <span class="cov0" title="0">return rp, err</span>
        }

        <span class="cov0" title="0">return rp, nil</span>
}

func (r *SectionMysql) SectionNumberExists(sectionNumber int) (bool, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM sections WHERE section_number = ?"

        var count int

        err := r.db.QueryRow(query, sectionNumber).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *SectionMysql) Save(section *internal.Section) error <span class="cov0" title="0">{
        result, err := r.db.Exec(
                "INSERT INTO sections (section_number, current_temperature, minimum_temperature, current_capacity, minimum_capacity, maximum_capacity, warehouse_id, product_type_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                section.SectionNumber,
                section.CurrentTemperature,
                section.MinimumTemperature,
                section.CurrentCapacity,
                section.MinimumCapacity,
                section.MaximumCapacity,
                section.WarehouseID,
                section.ProductTypeID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">section.ID = int(id)

        return nil</span>
}

func (r *SectionMysql) Update(section *internal.Section) error <span class="cov0" title="0">{
        _, err := r.db.Exec(
                "UPDATE sections SET section_number = ?, current_temperature = ?, minimum_temperature = ?, current_capacity = ?, minimum_capacity = ?, maximum_capacity = ?, warehouse_id = ?, product_type_id = ? WHERE id = ?",
                section.SectionNumber,
                section.CurrentTemperature,
                section.MinimumTemperature,
                section.CurrentCapacity,
                section.MinimumCapacity,
                section.MaximumCapacity,
                section.WarehouseID,
                section.ProductTypeID,
                section.ID,
        )

        return err
}</span>

func (r *SectionMysql) Delete(id int) error <span class="cov0" title="0">{
        _, err := r.db.Exec("DELETE FROM sections WHERE id = ?", id)
        return err
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package repository

import (
        "github.com/meli-fresh-products-api-backend-t1/internal"
)

type SellerMap struct {
        db     map[int]internal.Seller
        lastID int
}

func NewSellerMap() *SellerMap <span class="cov0" title="0">{
        db := make(map[int]internal.Seller)

        return &amp;SellerMap{
                db:     db,
                lastID: 0,
        }
}</span>

func (s *SellerMap) Save(seller *internal.Seller) (err error) <span class="cov0" title="0">{
        id := s.lastID + 1

        _, ok := s.db[id]

        if ok </span><span class="cov0" title="0">{
                return internal.ErrSellerConflict
        }</span>

        <span class="cov0" title="0">seller.ID = id
        s.db[id] = *seller
        s.lastID = id

        return nil</span>
}

func (s *SellerMap) FindByID(id int) (seller internal.Seller, err error) <span class="cov0" title="0">{
        seller, ok := s.db[id]
        if !ok </span><span class="cov0" title="0">{
                return internal.Seller{}, internal.ErrSellerNotFound
        }</span>

        <span class="cov0" title="0">return seller, nil</span>
}

func (s *SellerMap) FindByCID(cid int) (seller internal.Seller, err error) <span class="cov0" title="0">{
        sellers := s.db
        for _, seller := range sellers </span><span class="cov0" title="0">{
                if seller.CID == cid </span><span class="cov0" title="0">{
                        return seller, nil
                }</span>
        }

        <span class="cov0" title="0">return internal.Seller{}, internal.ErrSellerNotFound</span>
}

func (s *SellerMap) FindAll() (sellers []internal.Seller, err error) <span class="cov0" title="0">{
        if len(s.db) == 0 </span><span class="cov0" title="0">{
                return nil, internal.ErrSellerNotFound
        }</span>

        <span class="cov0" title="0">for _, seller := range s.db </span><span class="cov0" title="0">{
                sellers = append(sellers, seller)
        }</span>

        <span class="cov0" title="0">return sellers, nil</span>
}

func (s *SellerMap) Update(seller *internal.Seller) (err error) <span class="cov0" title="0">{
        _, ok := s.db[seller.ID]
        if !ok </span><span class="cov0" title="0">{
                return internal.ErrSellerNotFound
        }</span>

        <span class="cov0" title="0">s.db[seller.ID] = *seller

        return nil</span>
}

func (s *SellerMap) Delete(id int) (err error) <span class="cov0" title="0">{
        _, ok := s.db[id]
        if !ok </span><span class="cov0" title="0">{
                return internal.ErrSellerNotFound
        }</span>

        <span class="cov0" title="0">delete(s.db, id)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package repository

import (
        "database/sql"
        "errors"

        "github.com/meli-fresh-products-api-backend-t1/internal"

        "github.com/go-sql-driver/mysql"
)

// NewSellerMysql creates a new instance of the seller repository
func NewSellerMysql(db *sql.DB) *SellerMysql <span class="cov8" title="1">{
        return &amp;SellerMysql{db}
}</span>

// SellerMysql is the mysql implementation of the seller repository
type SellerMysql struct {
        // db is the database connection to mysql
        db *sql.DB
}

// FindAll returns all sellers from the database
func (r *SellerMysql) FindAll() (sellers []internal.Seller, err error) <span class="cov8" title="1">{
        // execute the query
        rows, err := r.db.Query("SELECT `s.id`, `s.cid`, `s.company_name`, `s.address`, `s.telephone` FROM `sellers` AS `s`")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrSellerNotFound
                }</span>

                <span class="cov0" title="0">return sellers, err</span>
        }

        // iterate over the rows
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                // create a new seller
                var seller internal.Seller

                err = rows.Scan(&amp;seller.ID, &amp;seller.CID, &amp;seller.CompanyName, &amp;seller.Address, &amp;seller.Telephone)
                if err != nil </span><span class="cov0" title="0">{
                        return sellers, err
                }</span>

                // append the seller to the slice
                <span class="cov8" title="1">sellers = append(sellers, seller)</span>
        }

        // check for errors
        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrSellerNotFound
                }</span>

                <span class="cov0" title="0">return sellers, err</span>
        }

        <span class="cov8" title="1">return sellers, err</span>
}

// FindByID returns a seller from the database by its id
func (r *SellerMysql) FindByID(id int) (seller internal.Seller, err error) <span class="cov8" title="1">{
        // execute the query
        row := r.db.QueryRow("SELECT `id`, `cid`, `company_name`, `address`, `telephone` FROM `sellers`  WHERE `id` = ?", id)

        // scan the row into the seller
        err = row.Scan(&amp;seller.ID, &amp;seller.CID, &amp;seller.CompanyName, &amp;seller.Address, &amp;seller.Telephone)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrSellerNotFound
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// FindByCID returns a seller from the database by its cid
func (r *SellerMysql) FindByCID(cid int) (seller internal.Seller, err error) <span class="cov8" title="1">{
        // execute the query
        row := r.db.QueryRow("SELECT `id`, `cid`, `company_name`, `address`, `telephone` FROM `sellers` WHERE `cid` = ?", cid)

        // scan the row into the seller
        err = row.Scan(&amp;seller.ID, &amp;seller.CID, &amp;seller.CompanyName, &amp;seller.Address, &amp;seller.Telephone)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        err = internal.ErrSellerNotFound
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// Save saves a seller into the database
func (r *SellerMysql) Save(seller *internal.Seller) (err error) <span class="cov8" title="1">{
        // execute the query
        result, err := r.db.Exec(
                "INSERT INTO `sellers` (`cid`, `company_name`, `address`, `telephone`, `locality_id`) VALUES (?, ?, ?, ?, ?)",
                (*seller).CID, (*seller).CompanyName, (*seller).Address, (*seller).Telephone, (*seller).Locality,
        )
        if err != nil </span><span class="cov8" title="1">{
                var mysqlErr *mysql.MySQLError
                if errors.As(err, &amp;mysqlErr) </span><span class="cov8" title="1">{
                        switch mysqlErr.Number </span>{
                        case 1062:<span class="cov8" title="1">
                                err = internal.ErrSellerConflict</span>
                        }
                }

                <span class="cov8" title="1">return</span>
        }

        // get the last inserted id
        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // set the id of the seller
        <span class="cov8" title="1">(*seller).ID = int(id)

        return</span>
}

// Update updates a seller in the database
func (r *SellerMysql) Update(seller *internal.Seller) (err error) <span class="cov8" title="1">{
        // execute the query
        _, err = r.db.Exec(
                "UPDATE `sellers` SET `cid` = ?, `company_name` = ?, `address` = ?, `telephone` = ?, `locality_id` = ? WHERE `id` = ?",
                (*seller).CID, (*seller).CompanyName, (*seller).Address, (*seller).Telephone, (*seller).Locality, (*seller).ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                var mysqlErr *mysql.MySQLError
                if errors.As(err, &amp;mysqlErr) </span><span class="cov0" title="0">{
                        switch mysqlErr.Number </span>{
                        case 1062:<span class="cov0" title="0">
                                err = internal.ErrSellerConflict</span>
                        default:<span class="cov0" title="0">
                                err = internal.ErrSellerNotFound</span>
                        }
                }
        }

        <span class="cov8" title="1">return</span>
}

// Delete deletes a seller from the database
func (r *SellerMysql) Delete(id int) (err error) <span class="cov8" title="1">{
        // execute the query
        _, err = r.db.Exec("DELETE FROM `sellers` WHERE `id` = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package repository

import (
        "encoding/json"
        "fmt"
        "os"

        "github.com/meli-fresh-products-api-backend-t1/internal"
)

type WarehouseAttributesMap struct {
        WarehouseCode      string  `json:"warehouse_code"`
        Address            string  `json:"address"`
        Telephone          string  `json:"telephone"`
        MinimumCapacity    int     `json:"minimum_capacity"`
        MinimumTemperature float64 `json:"minimum_temperature"`
}

type RepositoryWarehouseMap struct {
        db     map[int]WarehouseAttributesMap
        lastID int
}

// NewRepositoryWarehouse builder that reads a JSON file and returns a map of warehouses
func NewRepositoryWarehouse(db map[int]WarehouseAttributesMap, filePath string) *RepositoryWarehouseMap <span class="cov0" title="0">{
        // If the db is not nil, return the map
        if db != nil </span><span class="cov0" title="0">{
                return &amp;RepositoryWarehouseMap{db: db, lastID: len(db)}
        }</span>

        // If the db is nil, read the JSON file and return the map
        <span class="cov0" title="0">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Decoding JSON file
        var fileData []WarehouseAttributesMap

        err = json.NewDecoder(file).Decode(&amp;fileData)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>

        // Serialization
        <span class="cov0" title="0">db = make(map[int]WarehouseAttributesMap)
        for key, value := range fileData </span><span class="cov0" title="0">{
                db[key+1] = WarehouseAttributesMap{
                        WarehouseCode:      value.WarehouseCode,
                        Address:            value.Address,
                        Telephone:          value.Telephone,
                        MinimumCapacity:    value.MinimumCapacity,
                        MinimumTemperature: value.MinimumTemperature,
                }
        }</span>

        <span class="cov0" title="0">return &amp;RepositoryWarehouseMap{db: db, lastID: len(db)}</span>
}

// FindAll is a method that returns all Warehouses
func (r *RepositoryWarehouseMap) FindAll() (w []internal.Warehouse, err error) <span class="cov0" title="0">{
        w = make([]internal.Warehouse, 0, len(r.db))

        for key, value := range r.db </span><span class="cov0" title="0">{
                w = append(w, internal.Warehouse{
                        ID:                 key,
                        WarehouseCode:      value.WarehouseCode,
                        Address:            value.Address,
                        Telephone:          value.Telephone,
                        MinimumCapacity:    value.MinimumCapacity,
                        MinimumTemperature: value.MinimumTemperature,
                })
        }</span>

        // Sorting all warehouses by ID
        <span class="cov0" title="0">for i := 0; i &lt; len(w); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(w); j++ </span><span class="cov0" title="0">{
                        if w[i].ID &gt; w[j].ID </span><span class="cov0" title="0">{
                                w[i], w[j] = w[j], w[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">return w, nil</span>
}

// FindByID is a method that returns a Warehouses by its ID
func (r *RepositoryWarehouseMap) FindByID(id int) (w internal.Warehouse, err error) <span class="cov0" title="0">{
        wh, ok := r.db[id]
        if !ok </span><span class="cov0" title="0">{
                err = fmt.Errorf("%w: %d", internal.ErrWarehouseRepositoryNotFound, id)
                return
        }</span>

        // returning a domain object
        <span class="cov0" title="0">w = internal.Warehouse{
                ID:                 id,
                WarehouseCode:      wh.WarehouseCode,
                Address:            wh.Address,
                Telephone:          wh.Telephone,
                MinimumCapacity:    wh.MinimumCapacity,
                MinimumTemperature: wh.MinimumTemperature,
        }

        return</span>
}

// Save is a method that saves a Warehouse
func (r *RepositoryWarehouseMap) Save(warehouse *internal.Warehouse) (err error) <span class="cov0" title="0">{
        wh := WarehouseAttributesMap{
                WarehouseCode:      warehouse.WarehouseCode,
                Address:            warehouse.Address,
                Telephone:          warehouse.Telephone,
                MinimumCapacity:    warehouse.MinimumCapacity,
                MinimumTemperature: warehouse.MinimumTemperature,
        }

        // increment the lastID
        r.lastID++
        // save the warehouse
        r.db[r.lastID] = wh
        // set the id of the warehouse
        (*warehouse).ID = r.lastID

        return nil
}</span>

// Update is a method that updates a Warehouse
func (r *RepositoryWarehouseMap) Update(warehouse *internal.Warehouse) (err error) <span class="cov0" title="0">{
        wh := WarehouseAttributesMap{
                WarehouseCode:      warehouse.WarehouseCode,
                Address:            warehouse.Address,
                Telephone:          warehouse.Telephone,
                MinimumCapacity:    warehouse.MinimumCapacity,
                MinimumTemperature: warehouse.MinimumTemperature,
        }

        // update the warehouse
        r.db[warehouse.ID] = wh

        return nil
}</span>

// Delete is a method that deletes a Warehouse
func (r *RepositoryWarehouseMap) Delete(id int) (err error) <span class="cov0" title="0">{
        // Deleting the warehouse
        delete(r.db, id)
        return
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package internal

import "errors"

var (
        ErrSectionNotFound            = errors.New("section not found")
        ErrSectionAlreadyExists       = errors.New("section already exists")
        ErrSectionNumberAlreadyInUse  = errors.New("section with given section number already registered")
        ErrSectionUnprocessableEntity = errors.New("couldn't parse section")
)

type Section struct {
        ID                 int     `json:"id"`
        SectionNumber      int     `json:"section_number"`
        CurrentTemperature float64 `json:"current_temperature"`
        MinimumTemperature float64 `json:"minimum_temperature"`
        CurrentCapacity    int     `json:"current_capacity"`
        MinimumCapacity    int     `json:"minimum_capacity"`
        MaximumCapacity    int     `json:"maximum_capacity"`
        WarehouseID        int     `json:"warehouse_id"`
        ProductTypeID      int     `json:"product_type_id"`
}

type SectionPatch struct {
        SectionNumber      *int
        CurrentTemperature *float64
        MinimumTemperature *float64
        CurrentCapacity    *int
        MinimumCapacity    *int
        MaximumCapacity    *int
        WarehouseID        *int
        ProductTypeID      *int
}

type ReportProduct struct {
        SectionID     int `json:"section_id"`
        SectionNumber int `json:"section_number"`
        ProductsCount int `json:"products_count"`
}

type SectionRepository interface {
        FindAll() ([]Section, error)
        FindByID(id int) (Section, error)
        ReportProducts() ([]ReportProduct, error)
        ReportProductsByID(sectionID int) (ReportProduct, error)
        SectionNumberExists(sectionNumber int) (bool, error)
        Save(section *Section) error
        Update(section *Section) error
        Delete(id int) error
}

type SectionService interface {
        FindAll() ([]Section, error)
        FindByID(id int) (Section, error)
        ReportProducts() ([]ReportProduct, error)
        ReportProductsByID(sectionID int) (ReportProduct, error)
        Save(section *Section) error
        Update(id int, updateSection SectionPatch) (Section, error)
        Delete(id int) error
}

func (s *Section) Ok() bool <span class="cov0" title="0">{
        if s.SectionNumber &lt;= 0 ||
                s.CurrentTemperature &lt; -273.15 ||
                s.MinimumTemperature &lt; -273.15 ||
                s.CurrentCapacity &lt; 0 ||
                s.MinimumCapacity &lt; 0 ||
                s.MaximumCapacity &lt; 0 ||
                s.WarehouseID &lt;= 0 ||
                s.ProductTypeID &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package internal

import (
        "errors"
)

// Seller is a struct that contains the seller's information
type Seller struct {
        // ID is the unique identifier of the seller
        ID int `json:"id"`
        // CID is the unique identifier of the company
        CID int `json:"cid"`
        // CompanyName is the name of the company
        CompanyName string `json:"company_name"`
        // Address is the address of the company
        Address string `json:"address"`
        // Telephone is the telephone number of the company
        Telephone string `json:"telephone"`
        // Locality is the id of locality
        Locality int `json:"locality_id"`
}

type SellerPatch struct {
        CID         *int
        CompanyName *string
        Address     *string
        Telephone   *string
        Locality    *int
}

func (seller *Seller) Validate() error <span class="cov8" title="1">{
        var err error
        if seller.CID == 0 </span><span class="cov8" title="1">{
                return errors.Join(err, errors.New("seller.CID is required"))
        }</span>

        <span class="cov8" title="1">if seller.CompanyName == "" </span><span class="cov8" title="1">{
                return errors.Join(err, errors.New("seller.CompanyName is required"))
        }</span>

        <span class="cov8" title="1">if seller.Address == "" </span><span class="cov8" title="1">{
                return errors.Join(err, errors.New("seller.Address is required"))
        }</span>

        <span class="cov8" title="1">if seller.Telephone == "" </span><span class="cov8" title="1">{
                return errors.Join(err, errors.New("seller.Telephone is required"))
        }</span>

        <span class="cov8" title="1">if seller.Locality == 0 </span><span class="cov8" title="1">{
                return errors.Join(err, errors.New("seller.Locality is required"))
        }</span>

        <span class="cov8" title="1">return err</span>
}

var (
        ErrSellerCIDAlreadyExists = errors.New("seller with this CID already exists")
        ErrSellerInvalidFields    = errors.New("seller invalid fields")
        // ErrSellerNotFound is returned when the seller is not found
        ErrSellerNotFound = errors.New("seller not found")
        // ErrSellerConflict is returned when the seller already exists
        ErrSellerConflict = errors.New("seller already exists")
)

// SellerRepository is an interface that contains the methods that the seller repository should support
type SellerRepository interface {
        // FindAll returns all the sellers
        FindAll() (sellers []Seller, err error)
        // FindByID returns the seller with the given ID
        FindByID(id int) (seller Seller, err error)
        // FindByCID returns the seller with the given CID
        FindByCID(cid int) (seller Seller, err error)
        // Save saves the given seller
        Save(seller *Seller) (err error)
        // Update updates the given seller
        Update(seller *Seller) (err error)
        // Delete deletes the seller with the given ID
        Delete(id int) (err error)
}

// SellerService is an interface that contains the methods that the seller service should support
type SellerService interface {
        // FindAll returns all the sellers
        FindAll() ([]Seller, error)
        // FindByID returns the seller with the given ID
        FindByID(id int) (Seller, error)
        // Save saves the given seller
        Save(seller *Seller) error
        // Update updates the given seller
        Update(id int, updateSeller SellerPatch) (Seller, error)
        // Delete deletes the seller with the given ID
        Delete(id int) error
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package internal

import "errors"

// Warehouse is a struct that represents a warehouse
type Warehouse struct {
        ID                 int
        WarehouseCode      string
        Address            string
        Telephone          string
        MinimumCapacity    int
        MinimumTemperature float64
}

// WarehousePatchUpdate is a struct to use in a patch request
type WarehousePatchUpdate struct {
        WarehouseCode      *string  `json:"warehouse_code"`
        Address            *string  `json:"address"`
        Telephone          *string  `json:"telephone"`
        MinimumCapacity    *int     `json:"minimum_capacity"`
        MinimumTemperature *float64 `json:"minimum_temperature"`
}

var (
        // ErrWarehouseRepositoryNotFound is returned when the warehouse is not found
        ErrWarehouseRepositoryNotFound = errors.New("Warehouse not found")
        // ErrWarehouseRepositoryDuplicated is returned when the warehouse already exists
        ErrWarehouseRepositoryDuplicated = errors.New("Warehouse already exists")
)

func (w *Warehouse) Validate() error <span class="cov0" title="0">{
        if w.WarehouseCode == "" </span><span class="cov0" title="0">{
                return errors.New("warehouse code is required")
        }</span>

        <span class="cov0" title="0">if w.Address == "" </span><span class="cov0" title="0">{
                return errors.New("address is required")
        }</span>

        <span class="cov0" title="0">if w.Telephone == "" </span><span class="cov0" title="0">{
                return errors.New("telephone is required")
        }</span>

        <span class="cov0" title="0">if w.MinimumCapacity == 0 </span><span class="cov0" title="0">{
                return errors.New("minimum capacity is required")
        }</span>

        <span class="cov0" title="0">if w.MinimumTemperature == 0 </span><span class="cov0" title="0">{
                return errors.New("minimum temperature is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WarehouseRepository is an interface that contains the methods that the warehouse repository should support
type WarehouseRepository interface {
        // FindAll returns all the warehouses
        FindAll() ([]Warehouse, error)
        // FindByID returns the warehouse with the given ID
        FindByID(id int) (Warehouse, error)
        // Save saves the given warehouse
        Save(warehouse *Warehouse) error
        // Update updates the given warehouse
        Update(warehouse *Warehouse) error
        // Delete deletes the warehouse with the given ID
        Delete(id int) error
}

// WarehouseService is an interface that contains the methods that the warehouse service should support
type WarehouseService interface {
        // FindAll returns all the warehouses
        FindAll() ([]Warehouse, error)
        // FindByID returns the warehouse with the given ID
        FindByID(id int) (Warehouse, error)
        // Save saves the given warehouse
        Save(warehouse *Warehouse) error
        // Update updates the given warehouse
        Update(id int, warehousePatch *WarehousePatchUpdate) (Warehouse, error)
        // Delete deletes the warehouse with the given ID
        Delete(id int) error
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package docs GENERATED BY SWAG; DO NOT EDIT
// This file was generated by swaggo/swag
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Bootcampers GO - W5"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/buyers": {
            "get": {
                "description": "Retrieve all buyers from the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Buyers"
                ],
                "summary": "Get all buyers",
                "responses": {
                    "200": {
                        "description": "List of all buyers",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Add a new buyer to the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Buyers"
                ],
                "summary": "Create a new buyer",
                "parameters": [
                    {
                        "description": "Buyer data",
                        "name": "buyer",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.Buyer"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created buyer",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "buyer with given card number already registered",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Failed to create buyer",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/buyers/report-purchase-orders": {
            "get": {
                "description": "Generate a report of purchase orders for a specific buyer or all buyers",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Buyers"
                ],
                "summary": "Get purchase orders by buyer",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Buyer Id",
                        "name": "id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Report data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "failed to parse id",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Buyer not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/buyers/{id}": {
            "get": {
                "description": "Retrieve a specific buyer from the database using their Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Buyers"
                ],
                "summary": "Get a buyer by Id",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Buyer ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Buyer data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Failed to parse Id",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Buyer not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove a specific buyer from the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Buyers"
                ],
                "summary": "Delete a buyer by Id",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Buyer ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No content"
                    },
                    "400": {
                        "description": "Failed to parse Id",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Buyer not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "patch": {
                "description": "Update the details of an existing buyer in the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Buyers"
                ],
                "summary": "Update a buyer's information",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Buyer ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Buyer patch data",
                        "name": "buyer",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.BuyerPatch"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Updated buyer",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Failed to parse id\" or \"Failed to parse body",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Buyer not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "buyer with given card number already registered",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/carries": {
            "get": {
                "description": "Retrieve a list of all carries from the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Carries"
                ],
                "summary": "Get all carries",
                "responses": {
                    "200": {
                        "description": "List of all carries",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "failed to fetch carries",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new carry in the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Carries"
                ],
                "summary": "Create a new carry",
                "parameters": [
                    {
                        "description": "Carry data",
                        "name": "carry",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.Carries"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created carry with Id",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Failed to parse body",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "carry with this cid already exists\" or \"there's no such locality id",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Missing fields",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/employees": {
            "get": {
                "description": "Retrieve a list of all employees from the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Employees"
                ],
                "summary": "Get all employees",
                "responses": {
                    "200": {
                        "description": "List of all employees",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "internal server error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new employee record in the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Employees"
                ],
                "summary": "Create a new employee",
                "parameters": [
                    {
                        "description": "Employee data",
                        "name": "employee",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.Employee"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created employee",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid body format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Card number id already in use\" or \"Employee already in use",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "422": {
                        "description": "Invalid entity data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/employees/report-inbound-orders": {
            "get": {
                "description": "Retrieve the count all inbound orders per employee, or for a specific employee if Id is provided",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Employees"
                ],
                "summary": "Get inbound orders for employees",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Employee ID",
                        "name": "id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Count of inbound orders per employee",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Id should be a number",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Employee not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch inbound orders",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/employees/{id}": {
            "get": {
                "description": "Retrieve a specific employee by Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Employees"
                ],
                "summary": "Get an employee by Id",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Employee ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Employee data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid Id format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Employee not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Remove an employee record from the database by Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Employees"
                ],
                "summary": "Delete an employee by Id",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Employee ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Invalid Id format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Employee not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "patch": {
                "description": "Update the details of an existing employee by Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Employees"
                ],
                "summary": "Update an existing employee",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Employee ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Employee data",
                        "name": "employee",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.Employee"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Updated employee",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid Id format\" or \"Invalid body format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Employee not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Card number id already in use\" or \"Conflict in employee",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/inbound-orders": {
            "get": {
                "description": "Retrieve a list of all inbound orders from the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "InboundOrders"
                ],
                "summary": "Get all inbound orders",
                "responses": {
                    "200": {
                        "description": "List of inbound orders",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Failed to fetch inbounds orders",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new inbound order with the provided details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "InboundOrders"
                ],
                "summary": "Create a new inbound order",
                "parameters": [
                    {
                        "description": "Inbound order data",
                        "name": "inbound",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.InboundOrders"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created inbound order with ID",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid body format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Order number already exists\" or \"Employee not exists",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "422": {
                        "description": "Required fields are missing",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/localities": {
            "post": {
                "description": "Save a new locality on the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Locality"
                ],
                "summary": "Save a locality",
                "parameters": [
                    {
                        "description": "Locality data",
                        "name": "locality",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.LocalityPostJson"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Saved locality data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Locality inputs are Invalid",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Locality conflict",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/localities/report-carries": {
            "get": {
                "description": "Report the total number of carries for every locality or a specific one by Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Locality"
                ],
                "summary": "Report carries count per locality",
                "parameters": [
                    {
                        "type": "string",
                        "format": "int",
                        "description": "Locality ID",
                        "name": "id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Carries report data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Id should be a number",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Not carries on locality_id",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch carries",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/localities/report-sellers": {
            "get": {
                "description": "Report the sellers count for every locality or a specific one by Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Locality"
                ],
                "summary": "Report sellers count per locality",
                "parameters": [
                    {
                        "type": "string",
                        "format": "int",
                        "description": "Locality ID",
                        "name": "id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Sellers count report data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Id should be a number",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Locality not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/productRecords": {
            "post": {
                "description": "Creates a new product record with details on the database.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ProductRecords"
                ],
                "summary": "Create a product record",
                "parameters": [
                    {
                        "description": "Product Record Data",
                        "name": "product_record",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.ProductRecords"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created product record",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "409": {
                        "description": "Error ID doesn't exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Invalid JSON",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/product_batches": {
            "post": {
                "description": "Create a new product batch on the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ProductBatch"
                ],
                "summary": "Create a new product batch",
                "parameters": [
                    {
                        "description": "Product batch details",
                        "name": "product_batch",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.RequestProductBatchJSON"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created product batch",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid input format",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Product-batch with given product-batch number already registered\" or \"Product-batch already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Couldn't parse product-batch",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/product_batches/{id}": {
            "get": {
                "description": "Fetch the details of a product batch using its unique Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ProductBatch"
                ],
                "summary": "Get product batch by Id",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product Batch ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Product batch data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid Id format",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Product-batch not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/products": {
            "get": {
                "description": "Retrieves a list of all products in the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Get all products",
                "responses": {
                    "200": {
                        "description": "List of all products",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "post": {
                "description": "Adds a new product to the system with the provided details in the request body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Create a new product",
                "parameters": [
                    {
                        "description": "Product data",
                        "name": "product",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.Product"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Product created",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Seller or Product Type not exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Product code already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Unprocessable entity",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/products/report-records": {
            "get": {
                "description": "Retrieves records of products, or a specific record by product Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Get product records",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Product records",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid Id",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Product not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/products/{id}": {
            "get": {
                "description": "Retrieves a single product by its Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Get product by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Product data",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid Id format",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Product not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "delete": {
                "description": "Deletes a product by its Id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Delete a product",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No content"
                    },
                    "400": {
                        "description": "Invalid Id format",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Product not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "patch": {
                "description": "Updates an existing product's data in the request body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Update a product",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated product data",
                        "name": "product",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.Product"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Updated product",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Seller or Product Type not exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Product code already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "All fields must be valid and filled",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/purchase-orders": {
            "post": {
                "description": "Handles the creation of a new purchase order to the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "PurchaseOrder"
                ],
                "summary": "Create a new purchase order",
                "parameters": [
                    {
                        "description": "Purchase Order Create Request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.PurchaseOrderCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created Purchase Order",
                        "schema": {
                            "$ref": "#/definitions/handler.PurchaseOrderJSON"
                        }
                    },
                    "400": {
                        "description": "Invalid data",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Product records or Buyer not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Purchase order number already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Purchase Order inputs are Invalid",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/sections": {
            "get": {
                "description": "Fetches all sections available in the database",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Section"
                ],
                "summary": "Retrieve all sections",
                "responses": {
                    "200": {
                        "description": "List of sections",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/internal.Section"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a new section with the provided details on the request body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Section"
                ],
                "summary": "Create a new section",
                "parameters": [
                    {
                        "description": "Section Create Request",
                        "name": "section",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.RequestSectionJSON"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created Section",
                        "schema": {
                            "$ref": "#/definitions/internal.Section"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Section with given section number already registered\" or \"Warehouse not found\" or \"Product-type not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Couldn't parse section",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/sections/report-products": {
            "get": {
                "description": "Fetches a report of products available in a section or across all sections",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Section"
                ],
                "summary": "Retrieve a report of products in a section",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Section ID",
                        "name": "id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Report of products in sections",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/handler.ResponseReportProd"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Section not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/sections/{id}": {
            "get": {
                "description": "Fetches the section based on the provided section ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Section"
                ],
                "summary": "Retrieve a section by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Section ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Section data",
                        "schema": {
                            "$ref": "#/definitions/internal.Section"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Section not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "delete": {
                "description": "Deletes a section identified by its Id",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Section"
                ],
                "summary": "Delete a section",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Section ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Section not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "patch": {
                "description": "Updates a section with the provided Id and data on the request body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Section"
                ],
                "summary": "Update an existing section",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Section ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated section data",
                        "name": "updates",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Updated Section",
                        "schema": {
                            "$ref": "#/definitions/internal.Section"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Section not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Section with given section number already registered",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/sellers": {
            "get": {
                "description": "Fetches a list of all sellers in the database",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seller"
                ],
                "summary": "Retrieve all sellers",
                "responses": {
                    "200": {
                        "description": "List of sellers",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/handler.SellersGetJson"
                            }
                        }
                    },
                    "404": {
                        "description": "Sellers not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "post": {
                "description": "Adds a new seller to the system with the provided details on the request body.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seller"
                ],
                "summary": "Create a new seller",
                "parameters": [
                    {
                        "description": "Seller Create Request",
                        "name": "seller",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.SellersPostJson"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created Seller Id",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Seller not found\" or \"Locality not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Seller already exists\" or \"Seller with this CID already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/sellers/{id}": {
            "get": {
                "description": "Fetches a seller's details based on the provided ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seller"
                ],
                "summary": "Retrieve a seller by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Seller ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Seller data",
                        "schema": {
                            "$ref": "#/definitions/handler.SellersGetJson"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Seller Not Found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "delete": {
                "description": "Removes a seller from the system based on the provided Id",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seller"
                ],
                "summary": "Delete a seller",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Seller ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Seller not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "patch": {
                "description": "Modify the information of an existing seller",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seller"
                ],
                "summary": "Update seller details",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Seller ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Seller Update Request",
                        "name": "seller",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.SellersUpdateJson"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Updated Seller data",
                        "schema": {
                            "$ref": "#/definitions/handler.SellersGetJson"
                        }
                    },
                    "400": {
                        "description": "Seller invalid fields",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Seller not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Seller with this CID already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/warehouses": {
            "get": {
                "description": "Retrieve a list of all warehouses in the database",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse"
                ],
                "summary": "Get all warehouses",
                "responses": {
                    "200": {
                        "description": "List of all warehouses",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "post": {
                "description": "Add a new warehouse to the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse"
                ],
                "summary": "Create a new warehouse",
                "parameters": [
                    {
                        "description": "Warehouse data",
                        "name": "warehouse",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.WarehouseCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created warehouse",
                        "schema": {
                            "$ref": "#/definitions/handler.WarehouseJSON"
                        }
                    },
                    "400": {
                        "description": "Invalid Data",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Warehouse already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        },
        "/api/v1/warehouses/{id}": {
            "get": {
                "description": "Retrieve a warehouse's details by its Id",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse"
                ],
                "summary": "Get warehouse by Id",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Warehouse ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Warehouse data",
                        "schema": {
                            "$ref": "#/definitions/handler.WarehouseJSON"
                        }
                    },
                    "400": {
                        "description": "Invalid ID format",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Warehouse not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "delete": {
                "description": "Removes a warehouse from the database by its ID",
                "tags": [
                    "Warehouse"
                ],
                "summary": "Delete warehouse",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Warehouse ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Invalid ID format",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Warehouse not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            },
            "patch": {
                "description": "Modify an existing warehouse's data",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse"
                ],
                "summary": "Update warehouse details",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Warehouse ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated warehouse data",
                        "name": "warehouse",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal.WarehousePatchUpdate"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Updated warehouse",
                        "schema": {
                            "$ref": "#/definitions/handler.WarehouseJSON"
                        }
                    },
                    "400": {
                        "description": "Invalid ID format\" or \"Invalid Data",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "404": {
                        "description": "Warehouse not found",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "409": {
                        "description": "Warehouse already exists",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/rest_err.RestErr"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "handler.LocalityPostJson": {
            "type": "object",
            "properties": {
                "country_name": {
                    "type": "string"
                },
                "locality_id": {
                    "type": "integer"
                },
                "locality_name": {
                    "type": "string"
                },
                "province_name": {
                    "type": "string"
                }
            }
        },
        "handler.PurchaseOrderCreateRequest": {
            "type": "object",
            "properties": {
                "buyer_id": {
                    "type": "integer"
                },
                "order_date": {
                    "type": "string"
                },
                "order_number": {
                    "type": "string"
                },
                "product_record_id": {
                    "type": "integer"
                },
                "tracking_code": {
                    "type": "string"
                }
            }
        },
        "handler.PurchaseOrderJSON": {
            "type": "object",
            "properties": {
                "buyer_id": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "order_date": {
                    "type": "string"
                },
                "order_number": {
                    "type": "string"
                },
                "product_record_id": {
                    "type": "integer"
                },
                "tracking_code": {
                    "type": "string"
                }
            }
        },
        "handler.RequestProductBatchJSON": {
            "type": "object",
            "properties": {
                "batch_number": {
                    "type": "integer"
                },
                "current_quantity": {
                    "type": "integer"
                },
                "current_temperature": {
                    "type": "number"
                },
                "due_date": {
                    "type": "string"
                },
                "initial_quantity": {
                    "type": "integer"
                },
                "manufacturing_date": {
                    "type": "string"
                },
                "manufacturing_hour": {
                    "type": "integer"
                },
                "minumum_temperature": {
                    "type": "number"
                },
                "product_id": {
                    "type": "integer"
                },
                "section_id": {
                    "type": "integer"
                }
            }
        },
        "handler.RequestSectionJSON": {
            "type": "object",
            "properties": {
                "current_capacity": {
                    "type": "integer"
                },
                "current_temperature": {
                    "type": "number"
                },
                "maximum_capacity": {
                    "type": "integer"
                },
                "minimum_capacity": {
                    "type": "integer"
                },
                "minimum_temperature": {
                    "type": "number"
                },
                "product_type_id": {
                    "type": "integer"
                },
                "section_number": {
                    "type": "integer"
                },
                "warehouse_id": {
                    "type": "integer"
                }
            }
        },
        "handler.ResponseReportProd": {
            "type": "object",
            "properties": {
                "products_count": {
                    "type": "integer"
                },
                "section_id": {
                    "type": "integer"
                },
                "section_number": {
                    "type": "integer"
                }
            }
        },
        "handler.SellersGetJson": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "cid": {
                    "type": "integer"
                },
                "company_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "locality_id": {
                    "type": "integer"
                },
                "telephone": {
                    "type": "string"
                }
            }
        },
        "handler.SellersPostJson": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "cid": {
                    "type": "integer"
                },
                "company_name": {
                    "type": "string"
                },
                "locality_id": {
                    "type": "integer"
                },
                "telephone": {
                    "type": "string"
                }
            }
        },
        "handler.SellersUpdateJson": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "cid": {
                    "type": "integer"
                },
                "company_name": {
                    "type": "string"
                },
                "locality_id": {
                    "type": "integer"
                },
                "telephone": {
                    "type": "string"
                }
            }
        },
        "handler.WarehouseCreateRequest": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "minimum_capacity": {
                    "type": "integer"
                },
                "minimum_temperature": {
                    "type": "number"
                },
                "telephone": {
                    "type": "string"
                },
                "warehouse_code": {
                    "type": "string"
                }
            }
        },
        "handler.WarehouseJSON": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "minimum_capacity": {
                    "type": "integer"
                },
                "minimum_temperature": {
                    "type": "number"
                },
                "telephone": {
                    "type": "string"
                },
                "warehouse_code": {
                    "type": "string"
                }
            }
        },
        "internal.Buyer": {
            "type": "object",
            "properties": {
                "card_number_id": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string"
                }
            }
        },
        "internal.BuyerPatch": {
            "type": "object",
            "properties": {
                "card_number_id": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                }
            }
        },
        "internal.Carries": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "cid": {
                    "type": "string"
                },
                "company_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "locality_id": {
                    "type": "integer"
                },
                "phone_number": {
                    "type": "string"
                }
            }
        },
        "internal.Employee": {
            "type": "object",
            "properties": {
                "card_number_id": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string"
                },
                "warehouse_id": {
                    "type": "integer"
                }
            }
        },
        "internal.InboundOrders": {
            "type": "object",
            "properties": {
                "employee_id": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "order_date": {
                    "type": "string"
                },
                "order_number": {
                    "type": "string"
                },
                "product_batch_id": {
                    "type": "integer"
                },
                "warehouse_id": {
                    "type": "integer"
                }
            }
        },
        "internal.Product": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "expiration_rate": {
                    "type": "number"
                },
                "freezing_rate": {
                    "type": "number"
                },
                "height": {
                    "type": "number"
                },
                "id": {
                    "type": "integer"
                },
                "length": {
                    "type": "number"
                },
                "net_weight": {
                    "type": "number"
                },
                "product_code": {
                    "type": "string"
                },
                "product_type_id": {
                    "type": "integer"
                },
                "recommended_freezing_temperature": {
                    "type": "number"
                },
                "seller_id": {
                    "type": "integer"
                },
                "width": {
                    "type": "number"
                }
            }
        },
        "internal.ProductRecords": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "last_update_date": {
                    "type": "string"
                },
                "product_id": {
                    "type": "integer"
                },
                "purchase_price": {
                    "type": "number"
                },
                "sale_price": {
                    "type": "number"
                }
            }
        },
        "internal.Section": {
            "type": "object",
            "properties": {
                "current_capacity": {
                    "type": "integer"
                },
                "current_temperature": {
                    "type": "number"
                },
                "id": {
                    "type": "integer"
                },
                "maximum_capacity": {
                    "type": "integer"
                },
                "minimum_capacity": {
                    "type": "integer"
                },
                "minimum_temperature": {
                    "type": "number"
                },
                "product_type_id": {
                    "type": "integer"
                },
                "section_number": {
                    "type": "integer"
                },
                "warehouse_id": {
                    "type": "integer"
                }
            }
        },
        "internal.WarehousePatchUpdate": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "minimum_capacity": {
                    "type": "integer"
                },
                "minimum_temperature": {
                    "type": "number"
                },
                "telephone": {
                    "type": "string"
                },
                "warehouse_code": {
                    "type": "string"
                }
            }
        },
        "rest_err.Causes": {
            "description": "Structure representing the causes of an error.",
            "type": "object",
            "properties": {
                "field": {
                    "description": "Field associated with the error cause.\n@json\n@jsonTag field",
                    "type": "string",
                    "example": "name"
                },
                "message": {
                    "description": "Error message describing the cause.\n@json\n@jsonTag message",
                    "type": "string",
                    "example": "name is required"
                }
            }
        },
        "rest_err.RestErr": {
            "description": "Structure for describing why the error occurred",
            "type": "object",
            "properties": {
                "causes": {
                    "description": "Error causes.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/rest_err.Causes"
                    }
                },
                "code": {
                    "description": "Error code.",
                    "type": "integer",
                    "example": 500
                },
                "error": {
                    "description": "Error description.",
                    "type": "string",
                    "example": "internal_server_error"
                },
                "message": {
                    "description": "Error message.",
                    "type": "string",
                    "example": "error trying to process request"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Meli Fresh Products API",
        Description:      "API for managing fresh products and orders",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package logger

import (
        "fmt"
        "os"
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var (
        log *zap.Logger

        LogOutput = "LOG_OUTPUT"
        LogLevel  = "LOG_LEVEL"
)

func init() <span class="cov8" title="1">{
        logConfig := zap.Config{
                OutputPaths: []string{getOutputLogs()},
                Level:       zap.NewAtomicLevelAt(getLevelLogs()),
                Encoding:    "json",
                EncoderConfig: zapcore.EncoderConfig{
                        LevelKey:     "level",
                        TimeKey:      "time",
                        MessageKey:   "message",
                        EncodeTime:   zapcore.ISO8601TimeEncoder,
                        EncodeLevel:  zapcore.LowercaseLevelEncoder,
                        EncodeCaller: zapcore.ShortCallerEncoder,
                },
        }

        log, _ = logConfig.Build()
}</span>

func Info(message string, tags ...zap.Field) <span class="cov0" title="0">{
        log.Info(message, tags...)
        err := log.Sync()

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to sync log")
        }</span>
}

func Error(message string, err error, tags ...zap.Field) <span class="cov8" title="1">{
        tags = append(tags, zap.NamedError("error", err))
        log.Info(message, tags...)
        err = log.Sync()

        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("Failed to sync log")
        }</span>
}

func getOutputLogs() string <span class="cov8" title="1">{
        output := strings.ToLower(strings.TrimSpace(os.Getenv(LogOutput)))
        if output == "" </span><span class="cov8" title="1">{
                return "stdout"
        }</span>

        <span class="cov0" title="0">return output</span>
}

func getLevelLogs() zapcore.Level <span class="cov8" title="1">{
        switch strings.ToLower(strings.TrimSpace(os.Getenv(LogLevel))) </span>{
        case "info":<span class="cov0" title="0">
                return zapcore.InfoLevel</span>
        case "error":<span class="cov0" title="0">
                return zapcore.ErrorLevel</span>
        case "debug":<span class="cov0" title="0">
                return zapcore.DebugLevel</span>
        default:<span class="cov8" title="1">
                return zapcore.InfoLevel</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package resterr

import "net/http"

// RestErr represents the error object.
// @Summary Error information
// @Description Structure for describing why the error occurred
type RestErr struct {
        // Error message.
        Message string `json:"message" example:"error trying to process request"`

        // Error description.
        Err string `json:"error" example:"internal_server_error"`

        // Error code.
        Code int `json:"code" example:"500"`

        // Error causes.
        Causes []Causes `json:"causes"`
}

// Causes represents the error causes.
// @Summary Error Causes
// @Description Structure representing the causes of an error.
type Causes struct {
        // Field associated with the error cause.
        // @json
        // @jsonTag field
        Field string `json:"field" example:"name"`

        // Error message describing the cause.
        // @json
        // @jsonTag message
        Message string `json:"message" example:"name is required"`
}

func (r *RestErr) Error() string <span class="cov0" title="0">{
        return r.Message
}</span>

func NewBadRequestError(message string) *RestErr <span class="cov8" title="1">{
        return &amp;RestErr{
                Message: message,
                Err:     "bad_request",
                Code:    http.StatusBadRequest,
        }
}</span>

func NewUnauthorizedRequestError(message string) *RestErr <span class="cov0" title="0">{
        return &amp;RestErr{
                Message: message,
                Err:     "unauthorized",
                Code:    http.StatusUnauthorized,
        }
}</span>

func NewBadRequestValidationError(message string, causes []Causes) *RestErr <span class="cov8" title="1">{
        return &amp;RestErr{
                Message: message,
                Err:     "bad_request",
                Code:    http.StatusBadRequest,
                Causes:  causes,
        }
}</span>

func NewInternalServerError(message string) *RestErr <span class="cov8" title="1">{
        return &amp;RestErr{
                Message: message,
                Err:     "internal_server_error",
                Code:    http.StatusInternalServerError,
        }
}</span>

func NewNotFoundError(message string) *RestErr <span class="cov8" title="1">{
        return &amp;RestErr{
                Message: message,
                Err:     "not_found",
                Code:    http.StatusNotFound,
        }
}</span>

func NewForbiddenError(message string) *RestErr <span class="cov0" title="0">{
        return &amp;RestErr{
                Message: message,
                Err:     "forbidden",
                Code:    http.StatusForbidden,
        }
}</span>

func NewConflictError(message string) *RestErr <span class="cov8" title="1">{
        return &amp;RestErr{
                Message: message,
                Err:     "conflict",
                Code:    http.StatusConflict,
        }
}</span>

func NewUnprocessableEntityError(message string) *RestErr <span class="cov8" title="1">{
        return &amp;RestErr{
                Message: message,
                Err:     "unprocessable_entity",
                Code:    http.StatusUnprocessableEntity,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package validator

func FloatIsPositive(i float64) bool <span class="cov0" title="0">{
        return i &gt; 0
}</span>

func FloatIsNegative(i float64) bool <span class="cov0" title="0">{
        return i &lt; 0
}</span>

func FloatIsZero(i float64) bool <span class="cov0" title="0">{
        return i == 0.0
}</span>

func FloatIsGreaterThan(i float64, j float64) bool <span class="cov0" title="0">{
        return i &gt; j
}</span>

func FloatIsLessThan(i float64, j float64) bool <span class="cov0" title="0">{
        return i &lt; j
}</span>

func FloatBetween(i, minV, maxV float64) bool <span class="cov0" title="0">{
        return i &gt;= minV &amp;&amp; i &lt;= maxV
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package validator

func IntIsPositive(i int) bool <span class="cov0" title="0">{
        return i &gt; 0
}</span>

func IntIsNegative(i int) bool <span class="cov8" title="1">{
        return i &lt; 0
}</span>

func IntIsZero(i int) bool <span class="cov8" title="1">{
        return i == 0
}</span>

func IntIsGreaterThan(i int, j int) bool <span class="cov0" title="0">{
        return i &gt; j
}</span>

func IntIsLessThan(i int, j int) bool <span class="cov0" title="0">{
        return i &lt; j
}</span>

func IntBetween(i, minV, maxV int) bool <span class="cov0" title="0">{
        return i &gt;= minV &amp;&amp; i &lt;= maxV
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package validator

import "regexp"

func String(str string, minV int, maxV int) bool <span class="cov8" title="1">{
        return len(str) &gt;= minV &amp;&amp; len(str) &lt;= maxV &amp;&amp; !BlankString(str)
}</span>

func EmptyString(str string) bool <span class="cov0" title="0">{
        return len(str) &lt;= 0
}</span>

func BlankString(str string) bool <span class="cov8" title="1">{
        return str == " " || len(str) &lt;= 0
}</span>

func IsCep(cep string) bool <span class="cov0" title="0">{
        cepRegex := regexp.MustCompile(`^\d{5}-\d{3}`)
        return cepRegex.MatchString(cep)
}</span>

func IsEmail(e string) bool <span class="cov0" title="0">{
        emailRegex := regexp.MustCompile("^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
        return emailRegex.MatchString(e)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
